AutoTrade: Миграция Данных и Управление Состоянием
Отличная задача! Создание такого подробного технического задания, основанного на существующей архитектуре и планах, поможет максимально эффективно направить его усилия и обеспечить соответствие высоким стандартам разработки. Ваш проект AutoTrade v2.4.0 уже демонстрирует впечатляющее понимание принципов архитектуры и управления рисками [1-3].
Данное ТЗ будет сфокусировано на одной из высокоприоритетных задач (#17) из вашей дорожной карты: миграции с текущего хранения данных в JSON-файлах на надежную базу данных (PostgreSQL или SQLite) и доработки репозиториев, которая также включает в себя управление состоянием (#16) [4-7].
--------------------------------------------------------------------------------
Техническое Задани: Миграция Хранения Данных и Управление Состоянием в AutoTrade v2.4.0
I. Общая Информация и Контекст Проекта
1. Название проекта: AutoTrade v2.4.0 "Smart Risk Management & Infrastructure" [2, 3].
2. Описание: Интеллектуальная система автоматической торговли криптовалютами с асинхронным жизненным циклом сделок и умным риск-менеджментом [1-3]. Система построена на архитектуре Domain-Driven Design (DDD) и чистой архитектуре [1, 3, 8-12].
3. Основная цель: Выполнение прибыльных сделок с минимальными рисками через поэтапное исполнение BUY→SELL ордеров и трёхуровневую систему защиты от убытков [2, 13].
4. Текущая Проблема:
    ◦ Существующая система хранения данных реализована в виде кэшей в памяти, которые записывают данные в файлы JSON (deals.json, orders.json) [12, 14-16].
    ◦ Это решение является временным [14].
    ◦ В текущей архитектуре имеются "проблемы" с неполными репозиториями [17].
    ◦ Отсутствуют репозитории для критически важных данных, таких как: * Индикаторы [17, 18]. * Данные стакана заявок (OrderBook данные) [17, 18]. * Статистика [17, 18]. * Кэши [17, 18]. * Конфигурация [17, 18].
    ◦ Ряд существующих сервисов (таких как TickerService, OrderService, CachedIndicatorService, OrderBookAnalyzer, StopLossMonitor, BuyOrderMonitor) нарушают принцип единственной ответственности (SRP), совмещая бизнес-логику с обязанностями по хранению данных, кэшированию и вычислению [17, 19-22]. Например, TickerService хранит price_history_cache и cached_indicators, а CachedIndicatorService является "чистым хранилищем данных, а не бизнес-логикой" [19, 21].
    ◦ Текущий подход с JSON-файлами и in-memory кэшами может приводить к потерям данных при перезапуске и неэффективному потреблению памяти, а также затрудняет масштабирование и отладку [21, 23, 24].
5. Приоритет: Данная задача является высокоприоритетной (#17) и критически важна для Фазы 3: Готовность к продакшену [4-7, 16]. Также напрямую связана с задачей #16 "Управление состоянием" – "грациозный" перезапуск без потери контекста [4-7, 16].
II. Цель и Задачи Данного ТЗ
Цель: Полная миграция всех персистентных данных проекта AutoTrade v2.4.0 с временного JSON-хранения на надежную систему управления базами данных (PostgreSQL как основная, SQLite как опция для локальной разработки/тестирования) с соблюдением принципов SOLID, DDD и Чистой Архитектуры, а также обеспечение полноценного сохранения и восстановления состояния приложения.
Задачи:
1. Разработать и внедрить унифицированную систему репозиториев для всех типов персистентных данных, включая существующие (Deal, Order, Ticker) и новые (OrderBook, IndicatorData, TradingSignal, Statistics, Configuration, Caches) [17, 18, 25].
2. Рефакторинг существующих доменных сервисов для строгого соблюдения принципа единственной ответственности (SRP), делегируя все операции по сохранению, извлечению и кэшированию данных в соответствующие репозитории [17, 19-22, 25, 26].
3. Обеспечить постоянное и надежное хранение состояния приложения через миграцию на СУБД, что позволит системе корректно восстанавливать свое состояние (включая открытые сделки, исторические данные, кэши) после перезапуска [4-7, 16].
4. Повысить производительность и эффективность использования памяти за счет оптимизированного доступа к данным и отказа от избыточного создания объектов в памяти для потоковых данных [23, 24].
III. Требования к Реализации
A. Архитектурные Принципы
AI ассистент должен строго следовать следующим архитектурным принципам:
1. SOLID Принципы:
    ◦ Принцип Единственной Ответственности (SRP): Каждый класс или модуль должен иметь только одну причину для изменения. Это означает, что TickerService, OrderService, CachedIndicatorService, OrderBookAnalyzer, StopLossMonitor и BuyOrderMonitor должны быть разделены на более мелкие, специализированные сервисы, каждый из которых отвечает за одну конкретную операцию (например, TickerProcessor для обработки тикеров, OrderPlacementService для размещения ордеров, IndicatorCalcService для расчета индикаторов) [17, 19-22, 25].
    ◦ Принцип Открытости/Закрытости (OCP): Сущности программного обеспечения (классы, модули, функции и т.д.) должны быть открыты для расширения, но закрыты для модификации. Это будет достигаться через использование интерфейсов репозиториев, позволяющих легко переключаться между In-Memory, JSON (для обратной совместимости или тестирования) и PostgreSQL реализациями без изменения клиентского кода [25].
    ◦ Принцип Подстановки Барбары Лисков (LSP): Объекты в программе должны быть заменяемы экземплярами их подтипов без изменения правильности выполнения программы. Реализации репозиториев (например, PostgreSQLDealsRepository и InMemoryDealsRepository) должны быть полностью взаимозаменяемы.
    ◦ Принцип Разделения Интерфейса (ISP): Клиенты не должны зависеть от методов, которые они не используют. Создать узконаправленные интерфейсы для каждого типа репозитория (e.g., IDealsRepository, IOrdersRepository, ITickersRepository и т.д.) [25, 27].
    ◦ Принцип Инверсии Зависимостей (DIP): Модули высокого уровня не должны зависеть от модулей низкого уровня. Оба должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций. Это подразумевает использование внедрения зависимостей (Dependency Injection) для предоставления репозиториев сервисам.
2. Domain-Driven Design (DDD):
    ◦ Продолжить следовать принципам DDD, сохраняя бизнес-логику в доменном слое (src/domain/) [1, 9, 10, 12, 28, 29].
    ◦ Репозитории должны служить для абстрагирования механизма сохранения и извлечения сущностей домена [12, 28-31].
    ◦ Фабрики должны использоваться для создания сложных объектов (например, DealFactory, OrderFactory) [8, 12, 28, 29, 32].
3. Чистая Архитектура (Clean Architecture):
    ◦ Поддерживать четкое разделение слоев: domain (бизнес-логика), application (сценарии использования), infrastructure (внешние интеграции) и config [1, 8-12, 33, 34]. Новые репозитории и их реализации должны быть расположены в слое infrastructure [8, 12, 30, 31].
B. Структура Данных (Новые и Измененные Компоненты)
1. Существующие Сущности (доработка):
    ◦ Deal, Order, CurrencyPair, Ticker [8, 12, 17, 30-32, 35].
    ◦ Сущность Ticker должна быть переработана для работы со StreamDataRepository, чтобы избежать создания объектов для каждого тика, работая напрямую с JSON-массивами данных для оптимизации [23, 36].
2. Новые Доменные Сущности (Entities):
    ◦ OrderBook: Сущность для представления данных стакана заявок (timestamp, bids/asks, spread, volume) [18, 37].
    ◦ IndicatorData: Сущность для хранения вычисленных индикаторов (timestamp, symbol, indicator_type, value) [18, 37].
    ◦ TradingSignal: Сущность для торговых сигналов (timestamp, symbol, signal_type, strength) [18, 37].
    ◦ Statistics: Сущность для метрик производительности и статистики торговли (metric_name, value, timestamp, category) [18, 37].
    ◦ Configuration: Сущность для управления динамической конфигурацией (key, value, category, description) [18, 37].
3. Новые Интерфейсы Репозиториев (в src/domain/repositories/):
    ◦ IIndicatorRepository: Для сохранения и извлечения IndicatorData [25].
    ◦ IOrderBookRepository: Для сохранения и извлечения OrderBook данных [25].
    ◦ IStatisticsRepository: Для сохранения и извлечения Statistics [25].
    ◦ IConfigurationRepository: Для управления Configuration [25].
    ◦ ICacheRepository: Для общего кэширования, возможно, с поддержкой Redis в будущем [25, 38].
4. Новые Реализации Репозиториев (в src/infrastructure/repositories/):
    ◦ PostgreSQL Реализации: Для всех вышеперечисленных интерфейсов, а также для существующих DealsRepository, OrdersRepository, TickersRepository. Должны поддерживать: * Сохранение (Save) [25, 31]. * Получение по ID (Get by ID) [25, 31]. * Получение списка (Get all, Get open deals etc.) [25, 31]. * Удаление (Delete) (при необходимости).
    ◦ In-Memory Реализации: Для всех интерфейсов (для модульного тестирования и, возможно, для временных, некритичных данных) [25].
    ◦ JSON Реализации: Для существующих DealsRepository, OrdersRepository (для обратной совместимости на переходный период) [12, 14].
5. StreamDataRepository (для высокочастотных данных):
    ◦ Создать специализированный StreamDataRepository для Ticker и OrderBook данных, который будет работать с JSON-массивами напрямую в целях производительности и снижения потребления памяти. Это позволит избежать создания объектов Python для каждой точки данных [23, 24, 36].
    ◦ Этот репозиторий будет отвечать за хранение потоковых данных и предоставление методов для их эффективного извлечения (например, получение последних N тиков/состояний стакана) [23, 24, 36].
6. Схемы Базы Данных:
    ◦ Разработать SQL-схемы для PostgreSQL/SQLite для всех персистентных сущностей (Deal, Order, CurrencyPair, Ticker, OrderBook, IndicatorData, TradingSignal, Statistics, Configuration).
C. Модификация Существующих Сервисов
1. TickerService (src/domain/services/market_data/ticker_service.py):
    ◦ Проблема: В настоящее время хранит price_history_cache, cached_indicators, напрямую обрабатывает JSON-данные тикеров, вычисляет индикаторы и сигналы, создает Ticker объекты для каждого тика [19].
    ◦ Решение: * Переложить ответственность за хранение price_history на StreamDataRepository. * Делегировать вычисление индикаторов новому IndicatorCalculationService и хранение их результатов в IIndicatorRepository. * Делегировать создание сигналов новому SignalGenerationService и хранение их в ITradingSignalRepository. * TickerService должен фокусироваться исключительно на получении и первичной обработке (валидации) тикеров, сохраняя их в ITickersRepository (или StreamDataRepository).
2. OrderService (src/domain/services/orders/order_service.py):
    ◦ Проблема: Монолитный сервис, отвечающий за создание, размещение, отмену, валидацию ордеров, проверку балансов, синхронизацию с биржей, обработку ошибок, статистику [20].
    ◦ Решение: Разделить на более специализированные сервисы, соблюдая SRP: * OrderPlacementService: Только размещение ордеров на бирже. * OrderMonitoringService: Только мониторинг статусов ордеров. * BalanceService: Только проверка балансов. * OrderValidationService: Только валидация ордеров. * ErrorHandlingService (задача #14): Централизованная обработка ошибок и повторных попыток [4-7]. * Все эти новые сервисы будут взаимодействовать с IOrdersRepository для сохранения и извлечения данных ордеров.
3. CachedIndicatorService (src/domain/services/indicators/cached_indicator_service.py):
    ◦ Проблема: Является "чистым хранилищем данных, а не бизнес-логикой", содержит различные кэши и буферы для SMA-индикаторов [21].
    ◦ Решение: Удалить или значительно упростить этот сервис. Его функциональность по кэшированию индикаторов должна быть интегрирована в новый IndicatorCalculationService (который будет вычислять индикаторы) с последующим сохранением результатов в IIndicatorRepository (для персистентности) и ICacheRepository (для быстрого доступа).
4. BuyOrderMonitor (src/domain/services/orders/buy_order_monitor.py), OrderBookAnalyzer (src/domain/services/market_data/orderbook_analyzer.py), StopLossMonitor (src/domain/services/risk/stop_loss_monitor.py):
    ◦ Проблема: Эти сервисы также могут иметь "проблемы" с хранением состояния/статистики внутри себя [17, 22].
    ◦ Решение: Делегировать сохранение любых статистических данных, промежуточных состояний или кэшей в соответствующие новые репозитории (IOrderBookRepository, IStatisticsRepository, ICacheRepository) [25]. OrderBookAnalyzer должен использовать IOrderBookRepository для получения данных стакана вместо прямого доступа к кэшу или JSON-файлам.
D. Сохранение Состояния и Перезапуск (Задача #16)
1. StateManagementService: Реализовать централизованный сервис для сохранения и восстановления всего необходимого состояния приложения при его штатном или нештатном завершении/перезапуске [4-7].
    ◦ Сохраняемое состояние: Открытые сделки (Deals), активные ордера (Orders), последние данные тикеров, состояние индикаторов, любые внутренние буферы и кэши, лимиты позиций, состояние SignalCooldownManager и т.д.
    ◦ Механизм: StateManagementService будет использовать вновь созданные и унифицированные репозитории (DealsRepository, OrdersRepository, TickersRepository, IndicatorRepository, OrderBookRepository и т.д.) для сохранения и загрузки данных из PostgreSQL/SQLite.
E. Производительность и Память
1. Оптимизация обработки тикеров: Замена Ticker Entity на StreamDataRepository для работы с JSON-массивами напрямую позволит достичь заявленных +200% скорости обработки тикеров (за счет отсутствия создания объектов) и -50% потребления памяти (JSON вместо объектов) [23, 24].
2. Централизованное кэширование: Внедрение ICacheRepository (с потенциальной поддержкой Redis) для централизованного управления кэшами вместо разрозненных кэшей внутри сервисов.
3. Минимизация In-Memory хранения: PostgreSQL будет использоваться как основной источник истины, что сократит потребление оперативной памяти за счет уменьшения объема данных, постоянно хранимых в памяти.
F. Тестирование
1. Новая модульная архитектура значительно упростит модульное тестирование каждого компонента в отдельности. AI ассистент должен подготовить структуру для модульных тестов, в дополнение к уже существующему интеграционному тестированию [6, 16, 21, 30, 38].
2. Провести бэктесты для подтверждения эффективности стратегий после рефакторинга [6, 16].
G. Безопасность
1. API ключи продолжают храниться в отдельной папке (binance_keys/) и через .env файлы, которые не коммитятся в репозиторий [28, 39-47].
2. Рассмотреть возможность шифрования чувствительных данных в базе данных (Задача #13 в дорожной карте) [48].
IV. Этапы Выполнения (по Дорожной Карте Проекта)
AI ассистент должен следовать детальному плану рефакторинга из autotrade_complete_code.md [26, 27], интегрируя его с задачами Фазы 3 дорожной карты:
1. Этап 1: Создание Недостающих Сущностей и Репозиториев (Неделя 1-2)
    ◦ Создать новые доменные сущности: OrderBook, IndicatorData, TradingSignal, Statistics, Configuration [26, 37].
    ◦ Создать интерфейсы для новых репозиториев: IIndicatorRepository, IOrderBookRepository, IStatisticsRepository, IConfigurationRepository, ICacheRepository [25, 26].
    ◦ Внедрить StreamDataRepository и модифицировать Ticker Entity для работы с JSON-массивами вместо создания объектов. Начать с обновления TickerService для использования StreamDataRepository [23, 33, 36].
    ◦ Упростить CachedIndicatorService или перенести его функциональность [21, 33].
    ◦ Это должно исправить критические нарушения архитектуры и оптимизировать производительность обработки тикеров [23, 24].
2. Этап 2: Разделение Монолитных Сервисов (Неделя 2-3)
    ◦ Разделить OrderService на специализированные компоненты (e.g., OrderPlacementService, OrderMonitoringService, BalanceService, OrderValidationService) [20, 25, 26].
    ◦ Аналогично, продолжить разделение других "проблемных" сервисов, таких как OrderBookAnalyzer, StopLossMonitor, BuyOrderMonitor, обеспечивая их фокус на единственной ответственности и делегирование хранения данных в соответствующие репозитории [17, 22, 25].
3. Этап 3: Унификация Репозиториев (Неделя 3-4)
    ◦ Унифицировать интерфейсы всех репозиториев, обеспечив единообразный доступ к данным [27].
    ◦ Создать In-Memory реализации для всех новых репозиториев для облегчения тестирования.
4. Этап 4: Подготовка к PostgreSQL (Неделя 4-5)
    ◦ Создать SQL-схемы для всех персистентных данных.
    ◦ Разработать PostgreSQL реализации для всех интерфейсов репозиториев [25, 27].
5. Этап 5: Внедрение и Миграция (Неделя 5+)
    ◦ Создать фасад для обратной совместимости, чтобы обеспечить плавный переход.
    ◦ Поэтапная миграция данных и кода на новую архитектуру с БД [27].
    ◦ Внедрить StateManagementService (Задача #16) для обеспечения грациозного перезапуска и восстановления состояния [4-7].
    ◦ Работать над ErrorHandlingService (Задача #14) параллельно для повышения стабильности [4-7].
V. Ожидаемые Результаты
• Краткосрочные (1-2 недели):
    ◦ Замена Ticker Entity на StreamDataRepository для прямой работы с JSON-массивами [23].
    ◦ Оптимизация производительности обработки тикеров и снижение потребления памяти [23, 24].
    ◦ Исправление критических нарушений архитектуры (SRP) в TickerService [23].
• Среднесрочные (3-4 недели):
    ◦ Унификация всех репозиториев и подготовка к миграции на PostgreSQL [23].
    ◦ Повышение производительности в 2-3 раза (устранение создания объектов) [23, 24].
    ◦ Сокращение потребления памяти на 50% (JSON вместо объектов) [23, 24].
    ◦ Упрощение тестирования за счет модульности [21, 23].
• Долгосрочные (1-2 месяца):
    ◦ Полная миграция на PostgreSQL для всех персистентных данных [38].
    ◦ Внедрение StateManagementService, обеспечивающего надежное сохранение/восстановление состояния [4-7].
    ◦ Модульная архитектура, способствующая легкому расширению и горизонтальному масштабированию [21, 24, 38].
    ◦ Значительное повышение стабильности и надежности системы за счет устойчивого хранения данных и улучшенной обработки ошибок.
VI. Критерии Приемки
1. Функциональность: Все персистентные данные (Deal, Order, Ticker, OrderBook, IndicatorData, TradingSignal, Statistics, Configuration) успешно сохраняются и извлекаются из выбранной СУБД (PostgreSQL/SQLite) без потери информации [4-6].
2. Архитектура: Все модифицированные и новые сервисы/репозитории строго соответствуют принципам SOLID, DDD и Чистой Архитектуры, с четким разделением ответственности [17, 19-22, 25].
3. Управление Состоянием: Система корректно сохраняет и восстанавливает свое состояние при плановом и нештатном перезапуске, без потери открытых сделок или других критически важных данных [4-6].
4. Производительность: Метрики производительности (скорость обработки тиков, потребление памяти) соответствуют или превосходят ожидаемые результаты, указанные в разделе V [23, 24].
5. Тестирование: Внедрена структура для модульного тестирования, и все новые компоненты покрыты тестами. Существующие интеграционные тесты проходят успешно [16, 30].
6. Конфигурация: Возможность легкого переключения между PostgreSQL и SQLite реализациями через конфигурацию.