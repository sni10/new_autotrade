–û—Å–Ω–æ–≤—ã–≤–∞—è—Å—å –Ω–∞ –∞–Ω–∞–ª–∏–∑–µ —Å—Ç—Ä—É–∫—Ç—É—Ä –¥–∞–Ω–Ω—ã—Ö –∏ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ –∫–æ–¥–∞, —Å–æ–∑–¥–∞—é –ø–æ–¥—Ä–æ–±–Ω—ã–π –ø–ª–∞–Ω –º–∏–≥—Ä–∞—Ü–∏–∏ —Å —É–∫–∞–∑–∞–Ω–∏–µ–º –≤—Å–µ—Ö —Ñ–∞–π–ª–æ–≤, –º–µ—Ç–æ–¥–æ–≤ –∏ –∏–∑–º–µ–Ω–µ–Ω–∏–π:

# üìã AutoTrade v3.0: –ü–æ–ª–Ω—ã–π –ü–ª–∞–Ω –ú–∏–≥—Ä–∞—Ü–∏–∏ –Ω–∞ –î–≤—É—Ö—É—Ä–æ–≤–Ω–µ–≤—É—é –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—É

## üéØ –û–±–∑–æ—Ä –ú–∏–≥—Ä–∞—Ü–∏–∏

### –ö–æ–Ω—Ü–µ–ø—Ü–∏—è –Ω–æ–≤–æ–π –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã:
- **–£—Ä–æ–≤–µ–Ω—å 1 (RAM)**: –í—Å–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ —Å Pandas DataFrame –≤ –ø–∞–º—è—Ç–∏
- **–£—Ä–æ–≤–µ–Ω—å 2 (–î–∏—Å–∫)**: PostgreSQL –¥–ª—è –∞—Ç–æ–º–∞—Ä–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö + Parquet –¥–ª—è –ø–æ—Ç–æ–∫–æ–≤—ã—Ö
- **–ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è**: –ú–µ—Ç–æ–¥—ã `to_dataframe()` –∏ `from_dataframe()` –¥–ª—è –≤—Å–µ—Ö Entity

---

## üîß –®–ê–ì 1: –°–æ–∑–¥–∞–Ω–∏–µ –ë–∞–∑–æ–≤—ã—Ö –ê–±—Å—Ç—Ä–∞–∫—Ü–∏–π

### üìÅ `src/domain/repositories/base_repository.py` - –ù–û–í–´–ô –§–ê–ô–õ

```python
"""
–ë–∞–∑–æ–≤—ã–µ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ã –¥–ª—è –¥–≤—É—Ö—É—Ä–æ–≤–Ω–µ–≤–æ–π –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã —Ö—Ä–∞–Ω–µ–Ω–∏—è.
"""

from abc import ABC, abstractmethod
from typing import TypeVar, Generic, List, Optional, Dict, Any
import pandas as pd
from datetime import datetime

T_Entity = TypeVar('T_Entity')
T_EntityID = TypeVar('T_EntityID')

class IMemoryFirstRepository(Generic[T_Entity, T_EntityID], ABC):
    """–ë–∞–∑–æ–≤—ã–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –¥–ª—è –≤—Å–µ—Ö —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–µ–≤ —Å –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–æ–º –ø–∞–º—è—Ç–∏."""
    
    @abstractmethod
    async def save(self, entity: T_Entity) -> T_Entity:
        """–°–æ—Ö—Ä–∞–Ω—è–µ—Ç —Å—É—â–Ω–æ—Å—Ç—å –≤ DataFrame (–º–≥–Ω–æ–≤–µ–Ω–Ω–æ)."""
        pass
    
    @abstractmethod
    async def find_by_id(self, entity_id: T_EntityID) -> Optional[T_Entity]:
        """–ü–æ–∏—Å–∫ –ø–æ ID –≤ DataFrame."""
        pass
    
    @abstractmethod
    async def get_all(self) -> List[T_Entity]:
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –≤—Å–µ –∑–∞–ø–∏—Å–∏ –∏–∑ DataFrame."""
        pass
    
    @abstractmethod
    async def get_dataframe(self) -> pd.DataFrame:
        """–ü—Ä—è–º–æ–π –¥–æ—Å—Ç—É–ø –∫ DataFrame –¥–ª—è –∞–Ω–∞–ª–∏—Ç–∏–∫–∏."""
        pass
    
    @abstractmethod
    async def delete(self, entity_id: T_EntityID) -> bool:
        """–£–¥–∞–ª–µ–Ω–∏–µ –∏–∑ DataFrame + –ø–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ–≥–æ —Å–ª–æ—è."""
        pass

class IAtomicRepository(IMemoryFirstRepository[T_Entity, T_EntityID]):
    """–ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å –¥–ª—è –∞—Ç–æ–º–∞—Ä–Ω—ã—Ö —Å—É—â–Ω–æ—Å—Ç–µ–π (Deal, Order)."""
    
    @abstractmethod
    async def sync_to_persistent(self) -> None:
        """–ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–∞—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è —Å PostgreSQL."""
        pass

class IStreamRepository(IMemoryFirstRepository[T_Entity, T_EntityID]):
    """–ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å –¥–ª—è –ø–æ—Ç–æ–∫–æ–≤—ã—Ö –¥–∞–Ω–Ω—ã—Ö (Ticker, OrderBook)."""
    
    @abstractmethod
    async def append_batch(self, entities: List[T_Entity]) -> None:
        """–≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ–µ –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –ø–∞—á–∫–∏ –∑–∞–ø–∏—Å–µ–π."""
        pass
    
    @abstractmethod
    async def dump_to_parquet(self, filepath: str) -> int:
        """–°–±—Ä–æ—Å –Ω–∞–∫–æ–ø–ª–µ–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –≤ Parquet —Ñ–∞–π–ª."""
        pass
    
    @abstractmethod
    async def load_from_parquet(self, filepath: str) -> int:
        """–ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö –∏–∑ Parquet —Ñ–∞–π–ª–∞."""
        pass
```


---

## üèóÔ∏è –®–ê–ì 2: –°–æ–∑–¥–∞–Ω–∏–µ Data Transfer Objects

### üìÅ `src/domain/dto/dataframe_convertible.py` - –ù–û–í–´–ô –§–ê–ô–õ

```python
"""
–ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å –¥–ª—è –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ —Å—É—â–Ω–æ—Å—Ç–µ–π –≤ DataFrame –∏ –æ–±—Ä–∞—Ç–Ω–æ.
"""

from abc import ABC, abstractmethod
from typing import List, Dict, Any
import pandas as pd

class IDataFrameConvertible(ABC):
    """–ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å –¥–ª—è —Å—É—â–Ω–æ—Å—Ç–µ–π, –∫–æ—Ç–æ—Ä—ã–µ –º–æ–≥—É—Ç –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å—Å—è –≤ DataFrame."""
    
    @abstractmethod
    def to_dict(self) -> Dict[str, Any]:
        """–ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è —Å—É—â–Ω–æ—Å—Ç–∏ –≤ —Å–ª–æ–≤–∞—Ä—å –¥–ª—è DataFrame."""
        pass
    
    @classmethod
    @abstractmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'IDataFrameConvertible':
        """–°–æ–∑–¥–∞–Ω–∏–µ —Å—É—â–Ω–æ—Å—Ç–∏ –∏–∑ —Å–ª–æ–≤–∞—Ä—è DataFrame row."""
        pass
    
    @classmethod
    def list_to_dataframe(cls, entities: List['IDataFrameConvertible']) -> pd.DataFrame:
        """–ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è —Å–ø–∏—Å–∫–∞ —Å—É—â–Ω–æ—Å—Ç–µ–π –≤ DataFrame."""
        if not entities:
            return pd.DataFrame()
        
        data = [entity.to_dict() for entity in entities]
        df = pd.DataFrame(data)
        
        # –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∏–Ω–¥–µ–∫—Å–∞ –ø–æ ID –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –ø–æ–∏—Å–∫–∞
        if 'id' in df.columns:
            df.set_index('id', inplace=True)
        elif 'deal_id' in df.columns:
            df.set_index('deal_id', inplace=True)
        elif 'order_id' in df.columns:
            df.set_index('order_id', inplace=True)
            
        return df
    
    @classmethod
    def dataframe_to_list(cls, df: pd.DataFrame) -> List['IDataFrameConvertible']:
        """–ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è DataFrame –≤ —Å–ø–∏—Å–æ–∫ —Å—É—â–Ω–æ—Å—Ç–µ–π."""
        entities = []
        for _, row in df.iterrows():
            # –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω–¥–µ–∫—Å –æ–±—Ä–∞—Ç–Ω–æ –≤ –¥–∞–Ω–Ω—ã–µ
            row_dict = row.to_dict()
            if df.index.name and df.index.name not in row_dict:
                row_dict[df.index.name] = row.name
            entities.append(cls.from_dict(row_dict))
        return entities
```


---

## üì¶ –®–ê–ì 3: –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –°—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö Entity

### üìÅ `src/domain/entities/deal.py` - –ò–ó–ú–ï–ù–ï–ù–ò–ï

```python
from dataclasses import dataclass
from typing import Dict, Any, Optional
from datetime import datetime
from domain.dto.dataframe_convertible import IDataFrameConvertible

@dataclass
class Deal(IDataFrameConvertible):
    """–°—É—â–Ω–æ—Å—Ç—å —Å–¥–µ–ª–∫–∏ —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π DataFrame –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏."""
    
    STATUS_OPEN = "OPEN"
    STATUS_CLOSED = "CLOSED"
    STATUS_CANCELLED = "CANCELLED"
    
    deal_id: int
    currency_pair: str  # –ò–∑–º–µ–Ω–µ–Ω–æ —Å –æ–±—ä–µ–∫—Ç–∞ –Ω–∞ —Å—Ç—Ä–æ–∫—É –¥–ª—è —É–ø—Ä–æ—â–µ–Ω–∏—è
    status: str = STATUS_OPEN
    buy_order_id: Optional[int] = None
    sell_order_id: Optional[int] = None
    created_at: Optional[datetime] = None
    closed_at: Optional[datetime] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """–ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –≤ —Å–ª–æ–≤–∞—Ä—å –¥–ª—è DataFrame."""
        return {
            'deal_id': self.deal_id,
            'currency_pair': self.currency_pair,
            'status': self.status,
            'buy_order_id': self.buy_order_id,
            'sell_order_id': self.sell_order_id,
            'created_at': self.created_at.isoformat() if self.created_at else None,
            'closed_at': self.closed_at.isoformat() if self.closed_at else None,
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Deal':
        """–°–æ–∑–¥–∞–Ω–∏–µ –∏–∑ —Å–ª–æ–≤–∞—Ä—è DataFrame row."""
        return cls(
            deal_id=int(data['deal_id']),
            currency_pair=data['currency_pair'],
            status=data.get('status', cls.STATUS_OPEN),
            buy_order_id=int(data['buy_order_id']) if data.get('buy_order_id') else None,
            sell_order_id=int(data['sell_order_id']) if data.get('sell_order_id') else None,
            created_at=datetime.fromisoformat(data['created_at']) if data.get('created_at') else None,
            closed_at=datetime.fromisoformat(data['closed_at']) if data.get('closed_at') else None,
        )
```


### üìÅ `src/domain/entities/order.py` - –ò–ó–ú–ï–ù–ï–ù–ò–ï

```python
from dataclasses import dataclass
from typing import Dict, Any, Optional
from datetime import datetime
from decimal import Decimal
from domain.dto.dataframe_convertible import IDataFrameConvertible

@dataclass
class Order(IDataFrameConvertible):
    """–°—É—â–Ω–æ—Å—Ç—å –æ—Ä–¥–µ—Ä–∞ —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π DataFrame –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏."""
    
    STATUS_PENDING = "PENDING"
    STATUS_PLACED = "PLACED"
    STATUS_FILLED = "FILLED"
    STATUS_CANCELLED = "CANCELLED"
    STATUS_FAILED = "FAILED"
    
    SIDE_BUY = "BUY"
    SIDE_SELL = "SELL"
    
    order_id: int
    deal_id: int
    symbol: str
    side: str
    order_type: str
    amount: float
    price: float
    status: str = STATUS_PENDING
    exchange_id: Optional[str] = None
    filled_amount: float = 0.0
    average_price: float = 0.0
    fee: float = 0.0
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None
    error_message: Optional[str] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """–ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –≤ —Å–ª–æ–≤–∞—Ä—å –¥–ª—è DataFrame."""
        return {
            'order_id': self.order_id,
            'deal_id': self.deal_id,
            'symbol': self.symbol,
            'side': self.side,
            'order_type': self.order_type,
            'amount': self.amount,
            'price': self.price,
            'status': self.status,
            'exchange_id': self.exchange_id,
            'filled_amount': self.filled_amount,
            'average_price': self.average_price,
            'fee': self.fee,
            'created_at': self.created_at.isoformat() if self.created_at else None,
            'updated_at': self.updated_at.isoformat() if self.updated_at else None,
            'error_message': self.error_message,
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Order':
        """–°–æ–∑–¥–∞–Ω–∏–µ –∏–∑ —Å–ª–æ–≤–∞—Ä—è DataFrame row."""
        return cls(
            order_id=int(data['order_id']),
            deal_id=int(data['deal_id']),
            symbol=data['symbol'],
            side=data['side'],
            order_type=data['order_type'],
            amount=float(data['amount']),
            price=float(data['price']),
            status=data.get('status', cls.STATUS_PENDING),
            exchange_id=data.get('exchange_id'),
            filled_amount=float(data.get('filled_amount', 0.0)),
            average_price=float(data.get('average_price', 0.0)),
            fee=float(data.get('fee', 0.0)),
            created_at=datetime.fromisoformat(data['created_at']) if data.get('created_at') else None,
            updated_at=datetime.fromisoformat(data['updated_at']) if data.get('updated_at') else None,
            error_message=data.get('error_message'),
        )
```


### üìÅ `src/domain/entities/ticker.py` - –ò–ó–ú–ï–ù–ï–ù–ò–ï

```python
from dataclasses import dataclass
from typing import Dict, Any, Optional
from datetime import datetime
from domain.dto.dataframe_convertible import IDataFrameConvertible

@dataclass
class Ticker(IDataFrameConvertible):
    """–°—É—â–Ω–æ—Å—Ç—å —Ç–∏–∫–µ—Ä–∞ —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π DataFrame –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏."""
    
    symbol: str
    timestamp: int
    datetime: str
    high: float
    low: float
    bid: float
    ask: float
    last: float
    close: float
    base_volume: float
    quote_volume: float
    signals: Optional[Dict[str, float]] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """–ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –≤ —Å–ª–æ–≤–∞—Ä—å –¥–ª—è DataFrame."""
        return {
            'symbol': self.symbol,
            'timestamp': self.timestamp,
            'datetime': self.datetime,
            'high': self.high,
            'low': self.low,
            'bid': self.bid,
            'ask': self.ask,
            'last': self.last,
            'close': self.close,
            'base_volume': self.base_volume,
            'quote_volume': self.quote_volume,
            'signals': str(self.signals) if self.signals else None,  # JSON string
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Ticker':
        """–°–æ–∑–¥–∞–Ω–∏–µ –∏–∑ —Å–ª–æ–≤–∞—Ä—è DataFrame row."""
        signals = None
        if data.get('signals'):
            import json
            try:
                signals = json.loads(data['signals'].replace("'", '"'))
            except:
                signals = None
                
        return cls(
            symbol=data['symbol'],
            timestamp=int(data['timestamp']),
            datetime=data['datetime'],
            high=float(data['high']),
            low=float(data['low']),
            bid=float(data['bid']),
            ask=float(data['ask']),
            last=float(data['last']),
            close=float(data['close']),
            base_volume=float(data['base_volume']),
            quote_volume=float(data['quote_volume']),
            signals=signals,
        )
    
    # –°—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –º–µ—Ç–æ–¥—ã –æ—Å—Ç–∞—é—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π
    def update_signals(self, indicators: Dict[str, float]):
        """–û–±–Ω–æ–≤–ª—è–µ—Ç —Å–∏–≥–Ω–∞–ª—ã –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤."""
        self.signals = indicators.copy() if indicators else {}
    
    def get_macd_signal(self) -> float:
        return self.signals.get('macd', 0.0) if self.signals else 0.0
    
    def get_macd_signal_line(self) -> float:
        return self.signals.get('signal', 0.0) if self.signals else 0.0
    
    def get_macd_histogram(self) -> float:
        return self.signals.get('histogram', 0.0) if self.signals else 0.0
    
    def get_sma_7(self) -> float:
        return self.signals.get('sma_7', 0.0) if self.signals else 0.0
    
    def get_sma_25(self) -> float:
        return self.signals.get('sma_25', 0.0) if self.signals else 0.0
```


### üìÅ `src/domain/entities/indicator_data.py` - –ò–ó–ú–ï–ù–ï–ù–ò–ï

```python
from dataclasses import dataclass
from typing import Dict, Any
from domain.dto.dataframe_convertible import IDataFrameConvertible

@dataclass
class IndicatorData(IDataFrameConvertible):
    """–°—É—â–Ω–æ—Å—Ç—å –¥–∞–Ω–Ω—ã—Ö –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤ —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π DataFrame –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏."""
    
    symbol: str
    timestamp: int
    values: Dict[str, float]

    def to_dict(self) -> Dict[str, Any]:
        """–ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –≤ —Å–ª–æ–≤–∞—Ä—å –¥–ª—è DataFrame."""
        result = {
            'symbol': self.symbol,
            'timestamp': self.timestamp,
        }
        # –†–∞–∑–≤–æ—Ä–∞—á–∏–≤–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏—è –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤ –≤ –æ—Ç–¥–µ–ª—å–Ω—ã–µ –∫–æ–ª–æ–Ω–∫–∏
        result.update(self.values)
        return result

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'IndicatorData':
        """–°–æ–∑–¥–∞–Ω–∏–µ –∏–∑ —Å–ª–æ–≤–∞—Ä—è DataFrame row."""
        # –ò–∑–≤–ª–µ–∫–∞–µ–º –æ—Å–Ω–æ–≤–Ω—ã–µ –ø–æ–ª—è
        symbol = data.pop('symbol')
        timestamp = int(data.pop('timestamp'))
        
        # –í—Å–µ –æ—Å—Ç–∞–ª—å–Ω—ã–µ –ø–æ–ª—è - —ç—Ç–æ –∑–Ω–∞—á–µ–Ω–∏—è –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤
        values = {k: float(v) for k, v in data.items() if v is not None}
        
        return cls(
            symbol=symbol,
            timestamp=timestamp,
            values=values
        )

    @classmethod
    def from_dict_original(cls, data: Dict[str, Any]) -> 'IndicatorData':
        """–û—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π –º–µ—Ç–æ–¥ –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏."""
        return cls(
            symbol=data.get("symbol"),
            timestamp=data.get("timestamp"),
            values=data.get("values", {}),
        )

    def __repr__(self):
        return (f"<IndicatorData(symbol={self.symbol}, timestamp={self.timestamp}, "
                f"values_count={len(self.values)})>")
```


---

## üè≠ –®–ê–ì 4: –°–æ–∑–¥–∞–Ω–∏–µ –ù–æ–≤—ã—Ö –†–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–µ–≤

### üìÅ `src/infrastructure/repositories/deals_repository_v2.py` - –ù–û–í–´–ô –§–ê–ô–õ

```python
"""
–ù–æ–≤—ã–π —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π —Å–¥–µ–ª–æ–∫ —Å –¥–≤—É—Ö—É—Ä–æ–≤–Ω–µ–≤–æ–π –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–æ–π.
"""

import pandas as pd
from typing import List, Optional
import asyncio
from datetime import datetime

from domain.entities.deal import Deal
from domain.repositories.base_repository import IAtomicRepository
from infrastructure.database.postgresql_connection import PostgreSQLConnection

class DealsRepositoryV2(IAtomicRepository[Deal, int]):
    """–†–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π —Å–¥–µ–ª–æ–∫ —Å –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–æ–º –ø–∞–º—è—Ç–∏ –∏ –ø–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ—Å—Ç—å—é PostgreSQL."""
    
    def __init__(self, db_connection: PostgreSQLConnection):
        self.db_connection = db_connection
        self._dataframe: pd.DataFrame = pd.DataFrame()
        self._next_id = 1
        self._sync_lock = asyncio.Lock()
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ
        asyncio.create_task(self._initialize())
    
    async def _initialize(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è - –∑–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö –∏–∑ –ë–î."""
        await self._load_from_database()
    
    async def _load_from_database(self):
        """–ó–∞–≥—Ä—É–∂–∞–µ—Ç –≤—Å–µ —Å–¥–µ–ª–∫–∏ –∏–∑ PostgreSQL –≤ DataFrame."""
        query = """
        SELECT deal_id, currency_pair, status, buy_order_id, sell_order_id, 
               created_at, closed_at 
        FROM deals 
        ORDER BY deal_id
        """
        
        rows = await self.db_connection.fetch_all(query)
        if rows:
            data = []
            for row in rows:
                data.append({
                    'deal_id': row['deal_id'],
                    'currency_pair': row['currency_pair'],
                    'status': row['status'],
                    'buy_order_id': row['buy_order_id'],
                    'sell_order_id': row['sell_order_id'],
                    'created_at': row['created_at'].isoformat() if row['created_at'] else None,
                    'closed_at': row['closed_at'].isoformat() if row['closed_at'] else None,
                })
                self._next_id = max(self._next_id, row['deal_id'] + 1)
            
            self._dataframe = pd.DataFrame(data)
            self._dataframe.set_index('deal_id', inplace=True)
    
    async def save(self, entity: Deal) -> Deal:
        """–°–æ—Ö—Ä–∞–Ω—è–µ—Ç —Å–¥–µ–ª–∫—É –≤ DataFrame –∏ PostgreSQL."""
        # –ü—Ä–∏—Å–≤–∞–∏–≤–∞–µ–º ID –µ—Å–ª–∏ –µ–≥–æ –Ω–µ—Ç
        if entity.deal_id is None or entity.deal_id == 0:
            entity.deal_id = self._next_id
            self._next_id += 1
        
        # –û–±–Ω–æ–≤–ª—è–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–µ –º–µ—Ç–∫–∏
        if entity.created_at is None:
            entity.created_at = datetime.now()
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ DataFrame (–º–≥–Ω–æ–≤–µ–Ω–Ω–æ)
        row_data = entity.to_dict()
        if entity.deal_id in self._dataframe.index:
            # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–π –∑–∞–ø–∏—Å–∏
            for col, value in row_data.items():
                if col != 'deal_id':
                    self._dataframe.loc[entity.deal_id, col] = value
        else:
            # –ù–æ–≤–∞—è –∑–∞–ø–∏—Å—å
            new_row = pd.DataFrame([row_data])
            new_row.set_index('deal_id', inplace=True)
            self._dataframe = pd.concat([self._dataframe, new_row])
        
        # –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ —Å–æ—Ö—Ä–∞–Ω—è–µ–º –≤ PostgreSQL
        asyncio.create_task(self._save_to_database(entity))
        
        return entity
    
    async def _save_to_database(self, entity: Deal):
        """–°–æ—Ö—Ä–∞–Ω—è–µ—Ç —Å–¥–µ–ª–∫—É –≤ PostgreSQL."""
        async with self._sync_lock:
            query = """
            INSERT INTO deals (deal_id, currency_pair, status, buy_order_id, sell_order_id, created_at, closed_at)
            VALUES ($1, $2, $3, $4, $5, $6, $7)
            ON CONFLICT (deal_id) DO UPDATE SET
                status = EXCLUDED.status,
                buy_order_id = EXCLUDED.buy_order_id,
                sell_order_id = EXCLUDED.sell_order_id,
                closed_at = EXCLUDED.closed_at
            """
            
            await self.db_connection.execute(
                query,
                entity.deal_id,
                entity.currency_pair,
                entity.status,
                entity.buy_order_id,
                entity.sell_order_id,
                entity.created_at,
                entity.closed_at
            )
    
    async def find_by_id(self, deal_id: int) -> Optional[Deal]:
        """–ü–æ–∏—Å–∫ —Å–¥–µ–ª–∫–∏ –ø–æ ID –≤ DataFrame."""
        if deal_id in self._dataframe.index:
            row = self._dataframe.loc[deal_id]
            row_dict = row.to_dict()
            row_dict['deal_id'] = deal_id
            return Deal.from_dict(row_dict)
        return None
    
    async def get_all(self) -> List[Deal]:
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –≤—Å–µ —Å–¥–µ–ª–∫–∏ –∏–∑ DataFrame."""
        return Deal.dataframe_to_list(self._dataframe)
    
    async def get_dataframe(self) -> pd.DataFrame:
        """–ü—Ä—è–º–æ–π –¥–æ—Å—Ç—É–ø –∫ DataFrame."""
        return self._dataframe.copy()
    
    async def delete(self, deal_id: int) -> bool:
        """–£–¥–∞–ª–µ–Ω–∏–µ —Å–¥–µ–ª–∫–∏ –∏–∑ DataFrame –∏ PostgreSQL."""
        if deal_id not in self._dataframe.index:
            return False
        
        # –£–¥–∞–ª—è–µ–º –∏–∑ DataFrame
        self._dataframe.drop(deal_id, inplace=True)
        
        # –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ —É–¥–∞–ª—è–µ–º –∏–∑ PostgreSQL
        asyncio.create_task(self._delete_from_database(deal_id))
        
        return True
    
    async def _delete_from_database(self, deal_id: int):
        """–£–¥–∞–ª—è–µ—Ç —Å–¥–µ–ª–∫—É –∏–∑ PostgreSQL."""
        async with self._sync_lock:
            query = "DELETE FROM deals WHERE deal_id = $1"
            await self.db_connection.execute(query, deal_id)
    
    async def sync_to_persistent(self) -> None:
        """–ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–∞—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è —Å PostgreSQL."""
        async with self._sync_lock:
            # –ó–¥–µ—Å—å –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –ª–æ–≥–∏–∫—É –ø–æ–ª–Ω–æ–π —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
            pass
    
    # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã –¥–ª—è –±–∏–∑–Ω–µ—Å-–ª–æ–≥–∏–∫–∏
    async def get_open_deals(self) -> List[Deal]:
        """–ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –æ—Ç–∫—Ä—ã—Ç—ã–µ —Å–¥–µ–ª–∫–∏."""
        open_df = self._dataframe[self._dataframe['status'] == Deal.STATUS_OPEN]
        return Deal.dataframe_to_list(open_df)
    
    async def get_deals_by_currency_pair(self, currency_pair: str) -> List[Deal]:
        """–ü–æ–ª—É—á–∏—Ç—å —Å–¥–µ–ª–∫–∏ –ø–æ –≤–∞–ª—é—Ç–Ω–æ–π –ø–∞—Ä–µ."""
        filtered_df = self._dataframe[self._dataframe['currency_pair'] == currency_pair]
        return Deal.dataframe_to_list(filtered_df)
```


### üìÅ `src/infrastructure/repositories/orders_repository_v2.py` - –ù–û–í–´–ô –§–ê–ô–õ

```python
"""
–ù–æ–≤—ã–π —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π –æ—Ä–¥–µ—Ä–æ–≤ —Å –¥–≤—É—Ö—É—Ä–æ–≤–Ω–µ–≤–æ–π –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–æ–π.
"""

import pandas as pd
from typing import List, Optional
import asyncio
from datetime import datetime

from domain.entities.order import Order
from domain.repositories.base_repository import IAtomicRepository
from infrastructure.database.postgresql_connection import PostgreSQLConnection

class OrdersRepositoryV2(IAtomicRepository[Order, int]):
    """–†–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π –æ—Ä–¥–µ—Ä–æ–≤ —Å –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–æ–º –ø–∞–º—è—Ç–∏ –∏ –ø–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ—Å—Ç—å—é PostgreSQL."""
    
    def __init__(self, db_connection: PostgreSQLConnection):
        self.db_connection = db_connection
        self._dataframe: pd.DataFrame = pd.DataFrame()
        self._next_id = 1
        self._sync_lock = asyncio.Lock()
        
        asyncio.create_task(self._initialize())
    
    async def _initialize(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è."""
        await self._load_from_database()
    
    async def _load_from_database(self):
        """–ó–∞–≥—Ä—É–∂–∞–µ—Ç –≤—Å–µ –æ—Ä–¥–µ—Ä–∞ –∏–∑ PostgreSQL –≤ DataFrame."""
        query = """
        SELECT order_id, deal_id, symbol, side, order_type, amount, price, status,
               exchange_id, filled_amount, average_price, fee, created_at, updated_at, error_message
        FROM orders 
        ORDER BY order_id
        """
        
        rows = await self.db_connection.fetch_all(query)
        if rows:
            data = []
            for row in rows:
                data.append({
                    'order_id': row['order_id'],
                    'deal_id': row['deal_id'],
                    'symbol': row['symbol'],
                    'side': row['side'],
                    'order_type': row['order_type'],
                    'amount': float(row['amount']),
                    'price': float(row['price']),
                    'status': row['status'],
                    'exchange_id': row['exchange_id'],
                    'filled_amount': float(row['filled_amount'] or 0),
                    'average_price': float(row['average_price'] or 0),
                    'fee': float(row['fee'] or 0),
                    'created_at': row['created_at'].isoformat() if row['created_at'] else None,
                    'updated_at': row['updated_at'].isoformat() if row['updated_at'] else None,
                    'error_message': row['error_message'],
                })
                self._next_id = max(self._next_id, row['order_id'] + 1)
            
            self._dataframe = pd.DataFrame(data)
            self._dataframe.set_index('order_id', inplace=True)
    
    async def save(self, entity: Order) -> Order:
        """–°–æ—Ö—Ä–∞–Ω—è–µ—Ç –æ—Ä–¥–µ—Ä –≤ DataFrame –∏ PostgreSQL."""
        if entity.order_id is None or entity.order_id == 0:
            entity.order_id = self._next_id
            self._next_id += 1
        
        if entity.created_at is None:
            entity.created_at = datetime.now()
        entity.updated_at = datetime.now()
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ DataFrame
        row_data = entity.to_dict()
        if entity.order_id in self._dataframe.index:
            for col, value in row_data.items():
                if col != 'order_id':
                    self._dataframe.loc[entity.order_id, col] = value
        else:
            new_row = pd.DataFrame([row_data])
            new_row.set_index('order_id', inplace=True)
            self._dataframe = pd.concat([self._dataframe, new_row])
        
        # –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ —Å–æ—Ö—Ä–∞–Ω—è–µ–º –≤ PostgreSQL
        asyncio.create_task(self._save_to_database(entity))
        
        return entity
    
    async def _save_to_database(self, entity: Order):
        """–°–æ—Ö—Ä–∞–Ω—è–µ—Ç –æ—Ä–¥–µ—Ä –≤ PostgreSQL."""
        async with self._sync_lock:
            query = """
            INSERT INTO orders (order_id, deal_id, symbol, side, order_type, amount, price, status,
                              exchange_id, filled_amount, average_price, fee, created_at, updated_at, error_message)
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)
            ON CONFLICT (order_id) DO UPDATE SET
                status = EXCLUDED.status,
                exchange_id = EXCLUDED.exchange_id,
                filled_amount = EXCLUDED.filled_amount,
                average_price = EXCLUDED.average_price,
                fee = EXCLUDED.fee,
                updated_at = EXCLUDED.updated_at,
                error_message = EXCLUDED.error_message
            """
            
            await self.db_connection.execute(
                query,
                entity.order_id, entity.deal_id, entity.symbol, entity.side, entity.order_type,
                entity.amount, entity.price, entity.status, entity.exchange_id,
                entity.filled_amount, entity.average_price, entity.fee,
                entity.created_at, entity.updated_at, entity.error_message
            )
    
    async def find_by_id(self, order_id: int) -> Optional[Order]:
        """–ü–æ–∏—Å–∫ –æ—Ä–¥–µ—Ä–∞ –ø–æ ID –≤ DataFrame."""
        if order_id in self._dataframe.index:
            row = self._dataframe.loc[order_id]
            row_dict = row.to_dict()
            row_dict['order_id'] = order_id
            return Order.from_dict(row_dict)
        return None
    
    async def get_all(self) -> List[Order]:
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –≤—Å–µ –æ—Ä–¥–µ—Ä–∞ –∏–∑ DataFrame."""
        return Order.dataframe_to_list(self._dataframe)
    
    async def get_dataframe(self) -> pd.DataFrame:
        """–ü—Ä—è–º–æ–π –¥–æ—Å—Ç—É–ø –∫ DataFrame."""
        return self._dataframe.copy()
    
    async def delete(self, order_id: int) -> bool:
        """–£–¥–∞–ª–µ–Ω–∏–µ –æ—Ä–¥–µ—Ä–∞."""
        if order_id not in self._dataframe.index:
            return False
        
        self._dataframe.drop(order_id, inplace=True)
        asyncio.create_task(self._delete_from_database(order_id))
        return True
    
    async def _delete_from_database(self, order_id: int):
        """–£–¥–∞–ª—è–µ—Ç –æ—Ä–¥–µ—Ä –∏–∑ PostgreSQL."""
        async with self._sync_lock:
            query = "DELETE FROM orders WHERE order_id = $1"
            await self.db_connection.execute(query, order_id)
    
    async def sync_to_persistent(self) -> None:
        """–ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–∞—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è —Å PostgreSQL."""
        async with self._sync_lock:
            pass
    
    # –ë–∏–∑–Ω–µ—Å-–º–µ—Ç–æ–¥—ã
    async def get_open_orders(self) -> List[Order]:
        """–ü–æ–ª—É—á–∏—Ç—å –æ—Ç–∫—Ä—ã—Ç—ã–µ –æ—Ä–¥–µ—Ä–∞."""
        open_statuses = [Order.STATUS_PENDING, Order.STATUS_PLACED]
        open_df = self._dataframe[self._dataframe['status'].isin(open_statuses)]
        return Order.dataframe_to_list(open_df)
    
    async def get_orders_by_deal(self, deal_id: int) -> List[Order]:
        """–ü–æ–ª—É—á–∏—Ç—å –æ—Ä–¥–µ—Ä–∞ –ø–æ —Å–¥–µ–ª–∫–µ."""
        filtered_df = self._dataframe[self._dataframe['deal_id'] == deal_id]
        return Order.dataframe_to_list(filtered_df)
    
    async def get_orders_by_symbol(self, symbol: str) -> List[Order]:
        """–ü–æ–ª—É—á–∏—Ç—å –æ—Ä–¥–µ—Ä–∞ –ø–æ —Å–∏–º–≤–æ–ª—É."""
        filtered_df = self._dataframe[self._dataframe['symbol'] == symbol]
        return Order.dataframe_to_list(filtered_df)
```


### üìÅ `src/infrastructure/repositories/tickers_repository_v2.py` - –ù–û–í–´–ô –§–ê–ô–õ

```python
"""
–ù–æ–≤—ã–π —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π —Ç–∏–∫–µ—Ä–æ–≤ —Å –ø–æ—Ç–æ–∫–æ–≤–æ–π –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–æ–π –∏ Parquet –¥–∞–º–ø–∞–º–∏.
"""

import pandas as pd
from typing import List, Optional
import asyncio
import os
from datetime import datetime, date
import json

from domain.entities.ticker import Ticker
from domain.repositories.base_repository import IStreamRepository

class TickersRepositoryV2(IStreamRepository[Ticker, int]):
    """–†–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π —Ç–∏–∫–µ—Ä–æ–≤ —Å –Ω–∞–∫–æ–ø–ª–µ–Ω–∏–µ–º –≤ –ø–∞–º—è—Ç–∏ –∏ –¥–∞–º–ø–∞–º–∏ –≤ Parquet."""
    
    def __init__(self, dumps_directory: str = "dumps", max_memory_records: int = 10000):
        self.dumps_directory = dumps_directory
        self.max_memory_records = max_memory_records
        self._dataframe: pd.DataFrame = pd.DataFrame()
        self._next_id = 1
        self._dump_lock = asyncio.Lock()
        
        # –°–æ–∑–¥–∞–µ–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –¥–ª—è –¥–∞–º–ø–æ–≤
        os.makedirs(dumps_directory, exist_ok=True)
        
        asyncio.create_task(self._initialize())
    
    async def _initialize(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è - –∑–∞–≥—Ä—É–∂–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ –¥–∞–Ω–Ω—ã–µ –∏–∑ –¥–∞–º–ø–æ–≤."""
        await self._load_latest_dumps()
    
    async def _load_latest_dumps(self):
        """–ó–∞–≥—Ä—É–∂–∞–µ—Ç –ø–æ—Å–ª–µ–¥–Ω–∏–µ –¥–∞–º–ø—ã –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ."""
        today = date.today()
        yesterday = date.fromordinal(today.toordinal() - 1)
        
        # –ü—Ä–æ–±—É–µ–º –∑–∞–≥—Ä—É–∑–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –∑–∞ —Å–µ–≥–æ–¥–Ω—è –∏ –≤—á–µ—Ä–∞
        for target_date in [today, yesterday]:
            parquet_file = os.path.join(
                self.dumps_directory, 
                f"tickers_{target_date.strftime('%Y%m%d')}.parquet"
            )
            if os.path.exists(parquet_file):
                await self.load_from_parquet(parquet_file)
                break
    
    async def save(self, entity: Ticker) -> Ticker:
        """–°–æ—Ö—Ä–∞–Ω—è–µ—Ç —Ç–∏–∫–µ—Ä –≤ DataFrame –≤ –ø–∞–º—è—Ç–∏."""
        if not hasattr(entity, 'id'):
            entity.id = self._next_id
            self._next_id += 1
        
        # –î–æ–±–∞–≤–ª—è–µ–º –≤ DataFrame
        row_data = entity.to_dict()
        row_data['id'] = entity.id
        
        new_row = pd.DataFrame([row_data])
        new_row.set_index('id', inplace=True)
        self._dataframe = pd.concat([self._dataframe, new_row])
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ª–∏–º–∏—Ç –∑–∞–ø–∏—Å–µ–π –≤ –ø–∞–º—è—Ç–∏
        if len(self._dataframe) >= self.max_memory_records:
            asyncio.create_task(self._auto_dump())
        
        return entity
    
    async def append_batch(self, entities: List[Ticker]) -> None:
        """–≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ–µ –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –ø–∞—á–∫–∏ —Ç–∏–∫–µ—Ä–æ–≤."""
        if not entities:
            return
        
        data = []
        for entity in entities:
            if not hasattr(entity, 'id'):
                entity.id = self._next_id
                self._next_id += 1
            
            row_data = entity.to_dict()
            row_data['id'] = entity.id
            data.append(row_data)
        
        batch_df = pd.DataFrame(data)
        batch_df.set_index('id', inplace=True)
        self._dataframe = pd.concat([self._dataframe, batch_df])
        
        if len(self._dataframe) >= self.max_memory_records:
            asyncio.create_task(self._auto_dump())
    
    async def _auto_dump(self):
        """–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –¥–∞–º–ø –ø—Ä–∏ –ø—Ä–µ–≤—ã—à–µ–Ω–∏–∏ –ª–∏–º–∏—Ç–∞."""
        today = date.today()
        dump_file = os.path.join(
            self.dumps_directory,
            f"tickers_{today.strftime('%Y%m%d')}.parquet"
        )
        
        await self.dump_to_parquet(dump_file)
        
        # –û—á–∏—â–∞–µ–º –ø–æ–ª–æ–≤–∏–Ω—É —Å—Ç–∞—Ä—ã—Ö –∑–∞–ø–∏—Å–µ–π –∏–∑ –ø–∞–º—è—Ç–∏
        records_to_keep = self.max_memory_records // 2
        self._dataframe = self._dataframe.tail(records_to_keep)
    
    async def dump_to_parquet(self, filepath: str) -> int:
        """–°–±—Ä–∞—Å—ã–≤–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ –≤ Parquet —Ñ–∞–π–ª."""
        async with self._dump_lock:
            if self._dataframe.empty:
                return 0
            
            # –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è –∑–∞–ø–∏—Å–∏
            df_to_save = self._dataframe.copy()
            
            # –ï—Å–ª–∏ —Ñ–∞–π–ª —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, –æ–±—ä–µ–¥–∏–Ω—è–µ–º –¥–∞–Ω–Ω—ã–µ
            if os.path.exists(filepath):
                existing_df = pd.read_parquet(filepath)
                df_to_save = pd.concat([existing_df, df_to_save])
                df_to_save = df_to_save.drop_duplicates(subset=['timestamp', 'symbol'], keep='last')
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ Parquet
            df_to_save.to_parquet(filepath, compression='snappy')
            
            return len(df_to_save)
    
    async def load_from_parquet(self, filepath: str) -> int:
        """–ó–∞–≥—Ä—É–∂–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ –∏–∑ Parquet —Ñ–∞–π–ª–∞."""
        if not os.path.exists(filepath):
            return 0
        
        loaded_df = pd.read_parquet(filepath)
        
        if not loaded_df.empty:
            # –û–±—ä–µ–¥–∏–Ω—è–µ–º —Å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–º–∏ –¥–∞–Ω–Ω—ã–º–∏
            if not self._dataframe.empty:
                self._dataframe = pd.concat([self._dataframe, loaded_df])
                self._dataframe = self._dataframe.drop_duplicates(subset=['timestamp', 'symbol'], keep='last')
            else:
                self._dataframe = loaded_df
            
            # –û–±–Ω–æ–≤–ª—è–µ–º —Å—á–µ—Ç—á–∏–∫ ID
            if 'id' in self._dataframe.columns or self._dataframe.index.name == 'id':
                max_id = self._dataframe.index.max() if self._dataframe.index.name == 'id' else self._dataframe['id'].max()
                self._next_id = max(self._next_id, max_id + 1)
        
        return len(loaded_df)
    
    async def find_by_id(self, ticker_id: int) -> Optional[Ticker]:
        """–ü–æ–∏—Å–∫ —Ç–∏–∫–µ—Ä–∞ –ø–æ ID."""
        if ticker_id in self._dataframe.index:
            row = self._dataframe.loc[ticker_id]
            row_dict = row.to_dict()
            row_dict['id'] = ticker_id
            return Ticker.from_dict(row_dict)
        return None
    
    async def get_all(self) -> List[Ticker]:
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –≤—Å–µ —Ç–∏–∫–µ—Ä—ã –∏–∑ –ø–∞–º—è—Ç–∏."""
        return Ticker.dataframe_to_list(self._dataframe)
    
    async def get_dataframe(self) -> pd.DataFrame:
        """–ü—Ä—è–º–æ–π –¥–æ—Å—Ç—É–ø –∫ DataFrame."""
        return self._dataframe.copy()
    
    async def delete(self, ticker_id: int) -> bool:
        """–£–¥–∞–ª–µ–Ω–∏–µ —Ç–∏–∫–µ—Ä–∞ (–¥–ª—è –ø–æ—Ç–æ–∫–æ–≤—ã—Ö –¥–∞–Ω–Ω—ã—Ö —Ä–µ–¥–∫–æ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è)."""
        if ticker_id not in self._dataframe.index:
            return False
        
        self._dataframe.drop(ticker_id, inplace=True)
        return True
    
    async def get_last_n(self, n: int) -> List[Ticker]:
        """–ü–æ–ª—É—á–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω–∏–µ N —Ç–∏–∫–µ—Ä–æ–≤."""
        last_df = self._dataframe.tail(n)
        return Ticker.dataframe_to_list(last_df)
    
    async def get_by_symbol(self, symbol: str, limit: int = 1000) -> List[Ticker]:
        """–ü–æ–ª—É—á–∏—Ç—å —Ç–∏–∫–µ—Ä—ã –ø–æ —Å–∏–º–≤–æ–ª—É."""
        symbol_df = self._dataframe[self._dataframe['symbol'] == symbol].tail(limit)
        return Ticker.dataframe_to_list(symbol_df)
    
    async def get_price_history(self, symbol: str, limit: int = 200) -> List[float]:
        """–ü–æ–ª—É—á–∏—Ç—å –∏—Å—Ç–æ—Ä–∏—é —Ü–µ–Ω –¥–ª—è –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤."""
        symbol_df = self._dataframe[self._dataframe['symbol'] == symbol].tail(limit)
        return symbol_df['last'].tolist()
    
    # –°–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å —Å–æ —Å—Ç–∞—Ä—ã–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–æ–º
    @property
    def tickers(self) -> List[Ticker]:
        """–°–≤–æ–π—Å—Ç–≤–æ –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏."""
        return asyncio.run(self.get_all()) if not self._dataframe.empty else []
```


---

## üîß –®–ê–ì 5: –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –°–µ—Ä–≤–∏—Å–æ–≤

### üìÅ `src/domain/services/market_data/ticker_service.py` - –ò–ó–ú–ï–ù–ï–ù–ò–ï

```python
# src/domain/services/market_data/ticker_service.py
import time
from decimal import Decimal
from typing import Dict, List, Optional

from domain.entities.currency_pair import CurrencyPair
from domain.entities.ticker import Ticker
from domain.entities.indicator_data import IndicatorData
from domain.services.indicators.indicator_calculator_service import IndicatorCalculatorService
from domain.services.utils.decimal_rounding_service import DecimalRoundingService

# –ò–ó–ú–ï–ù–ï–ù–ò–ï: –ù–æ–≤—ã–µ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–∏
from infrastructure.repositories.tickers_repository_v2 import TickersRepositoryV2
from infrastructure.repositories.indicators_repository_v2 import IndicatorsRepositoryV2

class TickerService:
    def __init__(self, 
                 tickers_repo: TickersRepositoryV2,  # –ò–ó–ú–ï–ù–ï–ù–û
                 indicators_repo: IndicatorsRepositoryV2):  # –ò–ó–ú–ï–ù–ï–ù–û
        self.tickers_repo = tickers_repo
        self.indicators_repo = indicators_repo
        self.indicator_calculator = IndicatorCalculatorService()
        
        # –ö–µ—à —Ü–µ–Ω –¥–ª—è –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤
        self.price_history_cache: List[float] = []
        self.tick_count: int = 0
        self.last_medium_update_tick: int = 0
        self.last_heavy_update_tick: int = 0
        
        # –ò–ó–ú–ï–ù–ï–ù–ò–ï: –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–µ—à–∞ –∏–∑ DataFrame
        self._initialize_cache()

    def _initialize_cache(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–µ—à–∞ —Ü–µ–Ω –∏–∑ DataFrame."""
        # –ü–æ–ª—É—á–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ 200 —Ç–∏–∫–µ—Ä–æ–≤ –¥–ª—è –∏—Å—Ç–æ—Ä–∏–∏ —Ü–µ–Ω
        import asyncio
        try:
            last_tickers = asyncio.run(self.tickers_repo.get_last_n(200))
            if last_tickers:
                self.price_history_cache = [t.last for t in last_tickers]
                self.tick_count = len(self.price_history_cache)
        except:
            self.price_history_cache = []
            self.tick_count = 0

    def _should_update_medium(self) -> bool:
        return self.tick_count - self.last_medium_update_tick >= 10

    def _should_update_heavy(self) -> bool:
        return self.tick_count - self.last_heavy_update_tick >= 50

    async def process_ticker(self, ticker: Ticker):
        """
        –ò–ó–ú–ï–ù–ï–ù–ò–ï: –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç —Ç–∏–∫–µ—Ä —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –Ω–æ–≤—ã—Ö —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–µ–≤.
        """
        # –û–±–Ω–æ–≤–ª—è–µ–º –∫–µ—à —Ü–µ–Ω
        self.price_history_cache.append(ticker.last)
        if len(self.price_history_cache) > 200:
            self.price_history_cache.pop(0)
        
        self.tick_count += 1

        # –í—ã—á–∏—Å–ª—è–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã
        all_indicators = {}
        
        fast_indicators = self.indicator_calculator.calculate_fast_indicators(self.price_history_cache)
        all_indicators.update(fast_indicators.values)
        
        if self._should_update_medium():
            medium_indicators = self.indicator_calculator.calculate_medium_indicators(self.price_history_cache)
            all_indicators.update(medium_indicators.values)
            self.last_medium_update_tick = self.tick_count

        if self._should_update_heavy():
            heavy_indicators = self.indicator_calculator.calculate_heavy_indicators(self.price_history_cache)
            all_indicators.update(heavy_indicators.values)
            self.last_heavy_update_tick = self.tick_count

        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã
        if all_indicators:
            indicator_data = IndicatorData(
                symbol=ticker.symbol,
                timestamp=ticker.timestamp,
                values=all_indicators
            )
            await self.indicators_repo.save(indicator_data)  # –ò–ó–ú–ï–ù–ï–ù–û: async

        # –û–±–Ω–æ–≤–ª—è–µ–º —Å–∏–≥–Ω–∞–ª—ã —Ç–∏–∫–µ—Ä–∞ –∏ —Å–æ—Ö—Ä–∞–Ω—è–µ–º
        ticker.update_signals(all_indicators)
        await self.tickers_repo.save(ticker)  # –ò–ó–ú–ï–ù–ï–ù–û: async

    async def get_signal(self) -> str:
        """–ò–ó–ú–ï–ù–ï–ù–ò–ï: –ò—Å–ø–æ–ª—å–∑—É–µ–º DataFrame –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å–∏–≥–Ω–∞–ª–∞."""
        last_tickers = await self.tickers_repo.get_last_n(50)
        
        if len(last_tickers) < 50:
            return "HOLD"
            
        last_ticker = last_tickers[-1]
        if not last_ticker.signals:
            return "HOLD"

        macd = last_ticker.get_macd_signal()
        signal = last_ticker.get_macd_signal_line()
        hist = last_ticker.get_macd_histogram()
        sma_7 = last_ticker.get_sma_7()
        sma_25 = last_ticker.get_sma_25()

        if macd > signal and hist > 0 and sma_7 > sma_25:
            return "BUY"
        else:
            return "HOLD"

    # –ù–û–í–´–ô –ú–ï–¢–û–î: –ê–Ω–∞–ª–∏—Ç–∏–∫–∞ —á–µ—Ä–µ–∑ DataFrame
    async def get_analytics_dataframe(self) -> Dict[str, any]:
        """–ü–æ–ª—É—á–∏—Ç—å –∞–Ω–∞–ª–∏—Ç–∏–∫—É —á–µ—Ä–µ–∑ –ø—Ä—è–º–æ–π –¥–æ—Å—Ç—É–ø –∫ DataFrame."""
        df = await self.tickers_repo.get_dataframe()
        
        if df.empty:
            return {"error": "No data available"}
        
        return {
            "total_ticks": len(df),
            "symbols": df['symbol'].unique().tolist(),
            "price_stats": {
                "min": df['last'].min(),
                "max": df['last'].max(),
                "mean": df['last'].mean(),
                "std": df['last'].std()
            },
            "volume_stats": {
                "total_base_volume": df['base_volume'].sum(),
                "total_quote_volume": df['quote_volume'].sum(),
                "avg_base_volume": df['base_volume'].mean()
            },
            "time_range": {
                "from": df['timestamp'].min(),
                "to": df['timestamp'].max(),
                "duration_hours": (df['timestamp'].max() - df['timestamp'].min()) / 3600000
            }
        }

    # –û—Å—Ç–∞–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã –æ—Å—Ç–∞—é—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π
    def calculate_strategy(self, buy_price: float, budget: float, currency_pair: CurrencyPair, profit_percent: float):
        """–†–∞—Å—á–µ—Ç —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –æ—Å—Ç–∞–µ—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π."""
        price_step = Decimal(str(currency_pair.precision.get('price', '0.000001')))
        amount_step = Decimal(str(currency_pair.precision.get('amount', '0.0001')))
        price_precision = int(price_step.normalize().as_tuple().exponent * -1)
        amount_precision = int(amount_step.normalize().as_tuple().exponent * -1)
        min_notional = Decimal(str(currency_pair.limits.get('cost', {}).get('min', 10.0)))
        buy_price_dec = Decimal(str(buy_price))
        budget_dec = Decimal(str(budget))
        buy_fee_rate = Decimal(str(currency_pair.taker_fee))
        sell_fee_rate = Decimal(str(currency_pair.taker_fee))
        profit_dec = Decimal(str(profit_percent))

        if budget_dec < min_notional:
            return {"comment": f"‚ùå –ë—é–¥–∂–µ—Ç ({budget_dec}) –º–µ–Ω—å—à–µ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ –¥–æ–ø—É—Å—Ç–∏–º–æ–≥–æ ({min_notional})"}

        coins_to_buy_raw = budget_dec / buy_price_dec
        coins_to_buy = DecimalRoundingService.ceil_to_precision(coins_to_buy_raw, amount_precision)
        coins_after_buy_fee = coins_to_buy * (1 - buy_fee_rate)
        sell_price_raw = buy_price_dec * (1 + profit_dec) / (1 - sell_fee_rate)
        sell_price = DecimalRoundingService.round_to_precision(sell_price_raw, price_precision)
        coins_to_sell = DecimalRoundingService.floor_to_precision(coins_after_buy_fee, amount_precision)
        total_cost = coins_to_buy * buy_price_dec

        if total_cost < min_notional:
             return {"comment": f"‚ùå –ò—Ç–æ–≥–æ–≤–∞—è —Å—É–º–º–∞ –æ—Ä–¥–µ—Ä–∞ ({total_cost:.2f}) –º–µ–Ω—å—à–µ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ –¥–æ–ø—É—Å—Ç–∏–º–æ–π ({min_notional})"}

        final_revenue = coins_to_sell * sell_price
        net_profit = final_revenue - total_cost

        return (
            buy_price_dec,
            coins_to_buy,
            sell_price,
            coins_to_sell,
            {
                "comment": "‚úÖ –°–¥–µ–ª–∫–∞ –≤–æ–∑–º–æ–∂–Ω–∞.",
                "net_profit": f"{net_profit:.4f} USDT"
            }
        )

    async def get_last_price(self) -> Optional[float]:
        """–ò–ó–ú–ï–ù–ï–ù–ò–ï: –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–æ–≤—ã–π —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π."""
        last_tickers = await self.tickers_repo.get_last_n(1)
        return last_tickers[0].last if last_tickers else None
```


### üìÅ `src/domain/services/orders/order_service.py` - –ò–ó–ú–ï–ù–ï–ù–ò–ï

```python
# src/domain/services/orders/order_service.py
import logging
from typing import Optional, List
from domain.entities.order import Order, OrderExecutionResult
from domain.factories.order_factory import OrderFactory

# –ò–ó–ú–ï–ù–ï–ù–ò–ï: –ù–æ–≤—ã–π —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π
from infrastructure.repositories.orders_repository_v2 import OrdersRepositoryV2
from infrastructure.connectors.exchange_connector import CcxtExchangeConnector
import ccxt

logger = logging.getLogger(__name__)

class OrderService:
    def __init__(self, 
                 orders_repo: OrdersRepositoryV2,  # –ò–ó–ú–ï–ù–ï–ù–û
                 order_factory: OrderFactory, 
                 exchange_connector: CcxtExchangeConnector):
        self.orders_repo = orders_repo
        self.order_factory = order_factory
        self.exchange_connector = exchange_connector

    async def create_and_place_buy_order(self, symbol: str, amount: float, price: float, deal_id: int, order_type: str = "LIMIT") -> OrderExecutionResult:
        order = self.order_factory.create_buy_order(symbol, amount, price, deal_id, order_type)
        return await self._execute_order_on_exchange(order)

    async def create_local_sell_order(self, symbol: str, amount: float, price: float, deal_id: int, order_type: str = "LIMIT") -> OrderExecutionResult:
        order = self.order_factory.create_sell_order(symbol, amount, price, deal_id, order_type)
        order.status = Order.STATUS_PENDING
        await self.orders_repo.save(order)  # –ò–ó–ú–ï–ù–ï–ù–û: async
        return OrderExecutionResult(success=True, order=order)

    async def place_existing_order(self, order: Order) -> OrderExecutionResult:
        return await self._execute_order_on_exchange(order)

    async def _execute_order_on_exchange(self, order: Order) -> OrderExecutionResult:
        try:
            placed_order = await self.exchange_connector.create_order(order.symbol, order.side, order.order_type, order.amount, order.price)
            if isinstance(placed_order, Order):
                order.update_from_order(placed_order)
            else:
                order.update_from_exchange(placed_order)
            await self.orders_repo.save(order)  # –ò–ó–ú–ï–ù–ï–ù–û: async
            return OrderExecutionResult(success=True, order=order)
        except Exception as e:
            order.status = Order.STATUS_FAILED
            order.error_message = str(e)
            await self.orders_repo.save(order)  # –ò–ó–ú–ï–ù–ï–ù–û: async
            return OrderExecutionResult(success=False, order=order, error_message=str(e))

    async def get_order_status(self, order: Order) -> Order:
        if not order.exchange_id: 
            return order
        try:
            exchange_order = await self.exchange_connector.fetch_order(order.exchange_id, order.symbol)
            if isinstance(exchange_order, Order):
                order.update_from_order(exchange_order)
            else:
                order.update_from_exchange(exchange_order)
            await self.orders_repo.save(order)  # –ò–ó–ú–ï–ù–ï–ù–û: async
        except Exception as e:
            logger.error(f"Error checking order status for {order.order_id}: {e}")
        return order

    async def cancel_order(self, order: Order) -> bool:
        if not order.exchange_id: 
            return False
        try:
            cancelled_order = await self.exchange_connector.cancel_order(order.exchange_id, order.symbol)
            if isinstance(cancelled_order, Order):
                order.update_from_order(cancelled_order)
            else:
                order.update_from_exchange(cancelled_order)
            await self.orders_repo.save(order)  # –ò–ó–ú–ï–ù–ï–ù–û: async
            return True
        except Exception as e:
            logger.error(f"Failed to cancel order {order.order_id}: {e}")
            return False

    # –ò–ó–ú–ï–ù–ï–ù–ò–ï: –ù–æ–≤—ã–µ –º–µ—Ç–æ–¥—ã —Å async
    async def get_open_orders(self) -> List[Order]: 
        return await self.orders_repo.get_open_orders()
    
    async def get_order_by_id(self, order_id: int) -> Optional[Order]: 
        return await self.orders_repo.find_by_id(order_id)
    
    # –ù–û–í–´–ô –ú–ï–¢–û–î: –ê–Ω–∞–ª–∏—Ç–∏–∫–∞ —á–µ—Ä–µ–∑ DataFrame
    async def get_orders_analytics(self) -> Dict[str, any]:
        """–ü–æ–ª—É—á–∏—Ç—å –∞–Ω–∞–ª–∏—Ç–∏–∫—É –æ—Ä–¥–µ—Ä–æ–≤ —á–µ—Ä–µ–∑ DataFrame."""
        df = await self.orders_repo.get_dataframe()
        
        if df.empty:
            return {"error": "No orders data"}
        
        return {
            "total_orders": len(df),
            "status_distribution": df['status'].value_counts().to_dict(),
            "side_distribution": df['side'].value_counts().to_dict(),
            "total_volume": df['amount'].sum(),
            "average_price": df['price'].mean(),
            "fee_total": df['fee'].sum(),
            "symbols": df['symbol'].unique().tolist()
        }
```


---

## üóÑÔ∏è –®–ê–ì 6: –°–æ–∑–¥–∞–Ω–∏–µ PostgreSQL –°—Ö–µ–º—ã

### üìÅ `database/migrations/001_create_tables.sql` - –ù–û–í–´–ô –§–ê–ô–õ

```sql
-- –ú–∏–≥—Ä–∞—Ü–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è —Ç–∞–±–ª–∏—Ü PostgreSQL

-- –¢–∞–±–ª–∏—Ü–∞ —Å–¥–µ–ª–æ–∫
CREATE TABLE IF NOT EXISTS deals (
    deal_id SERIAL PRIMARY KEY,
    currency_pair VARCHAR(20) NOT NULL,
    status VARCHAR(20) NOT NULL DEFAULT 'OPEN',
    buy_order_id INTEGER,
    sell_order_id INTEGER,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    closed_at TIMESTAMP WITH TIME ZONE,
    
    CONSTRAINT deals_status_check CHECK (status IN ('OPEN', 'CLOSED', 'CANCELLED'))
);

-- –¢–∞–±–ª–∏—Ü–∞ –æ—Ä–¥–µ—Ä–æ–≤
CREATE TABLE IF NOT EXISTS orders (
    order_id SERIAL PRIMARY KEY,
    deal_id INTEGER NOT NULL,
    symbol VARCHAR(20) NOT NULL,
    side VARCHAR(10) NOT NULL,
    order_type VARCHAR(20) NOT NULL,
    amount DECIMAL(20, 8) NOT NULL,
    price DECIMAL(20, 8) NOT NULL,
    status VARCHAR(20) NOT NULL DEFAULT 'PENDING',
    exchange_id VARCHAR(100),
    filled_amount DECIMAL(20, 8) DEFAULT 0,
    average_price DECIMAL(20, 8) DEFAULT 0,
    fee DECIMAL(20, 8) DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    error_message TEXT,
    
    FOREIGN KEY (deal_id) REFERENCES deals(deal_id) ON DELETE CASCADE,
    CONSTRAINT orders_side_check CHECK (side IN ('BUY', 'SELL')),
    CONSTRAINT orders_status_check CHECK (status IN ('PENDING', 'PLACED', 'FILLED', 'CANCELLED', 'FAILED'))
);

-- –¢–∞–±–ª–∏—Ü–∞ –≤–∞–ª—é—Ç–Ω—ã—Ö –ø–∞—Ä
CREATE TABLE IF NOT EXISTS currency_pairs (
    symbol VARCHAR(20) PRIMARY KEY,
    base_currency VARCHAR(10) NOT NULL,
    quote_currency VARCHAR(10) NOT NULL,
    price_precision INTEGER DEFAULT 8,
    amount_precision INTEGER DEFAULT 8,
    min_amount DECIMAL(20, 8),
    max_amount DECIMAL(20, 8),
    min_price DECIMAL(20, 8),
    max_price DECIMAL(20, 8),
    min_notional DECIMAL(20, 8),
    taker_fee DECIMAL(10, 6) DEFAULT 0.001,
    maker_fee DECIMAL(10, 6) DEFAULT 0.001,
    active BOOLEAN DEFAULT true,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- –ò–Ω–¥–µ–∫—Å—ã –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
CREATE INDEX IF NOT EXISTS idx_deals_status ON deals(status);
CREATE INDEX IF NOT EXISTS idx_deals_currency_pair ON deals(currency_pair);
CREATE INDEX IF NOT EXISTS idx_deals_created_at ON deals(created_at);

CREATE INDEX IF NOT EXISTS idx_orders_deal_id ON orders(deal_id);
CREATE INDEX IF NOT EXISTS idx_orders_status ON orders(status);
CREATE INDEX IF NOT EXISTS idx_orders_symbol ON orders(symbol);
CREATE INDEX IF NOT EXISTS idx_orders_exchange_id ON orders(exchange_id);
CREATE INDEX IF NOT EXISTS idx_orders_created_at ON orders(created_at);

-- –¢—Ä–∏–≥–≥–µ—Ä –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è updated_at –≤ orders
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_orders_updated_at 
    BEFORE UPDATE ON orders 
    FOR EACH ROW 
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_currency_pairs_updated_at 
    BEFORE UPDATE ON currency_pairs 
    FOR EACH ROW 
    EXECUTE FUNCTION update_updated_at_column();
```


### üìÅ `src/infrastructure/database/postgresql_connection.py` - –ù–û–í–´–ô –§–ê–ô–õ

```python
"""
–ú–µ–Ω–µ–¥–∂–µ—Ä –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–π –∫ PostgreSQL —Å –ø—É–ª–æ–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π.
"""

import asyncio
import asyncpg
from typing import List, Dict, Any, Optional
import logging
from contextlib import asynccontextmanager

logger = logging.getLogger(__name__)

class PostgreSQLConnection:
    """–ú–µ–Ω–µ–¥–∂–µ—Ä –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–π –∫ PostgreSQL."""
    
    def __init__(self, connection_string: str, min_size: int = 5, max_size: int = 20):
        self.connection_string = connection_string
        self.min_size = min_size
        self.max_size = max_size
        self._pool: Optional[asyncpg.Pool] = None
        self._lock = asyncio.Lock()
    
    async def initialize(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—É–ª–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π."""
        async with self._lock:
            if self._pool is None:
                self._pool = await asyncpg.create_pool(
                    self.connection_string,
                    min_size=self.min_size,
                    max_size=self.max_size,
                    command_timeout=60
                )
                logger.info(f"PostgreSQL pool initialized with {self.min_size}-{self.max_size} connections")
    
    async def close(self):
        """–ó–∞–∫—Ä—ã—Ç–∏–µ –ø—É–ª–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π."""
        if self._pool:
            await self._pool.close()
            self._pool = None
            logger.info("PostgreSQL pool closed")
    
    @asynccontextmanager
    async def get_connection(self):
        """Context manager –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –∏–∑ –ø—É–ª–∞."""
        if not self._pool:
            await self.initialize()
        
        async with self._pool.acquire() as connection:
            yield connection
    
    async def execute(self, query: str, *args) -> str:
        """–í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ INSERT/UPDATE/DELETE –∑–∞–ø—Ä–æ—Å–∞."""
        async with self.get_connection() as conn:
            return await conn.execute(query, *args)
    
    async def fetch_one(self, query: str, *args) -> Optional[Dict[str, Any]]:
        """–í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ SELECT –∑–∞–ø—Ä–æ—Å–∞ —Å –≤–æ–∑–≤—Ä–∞—Ç–æ–º –æ–¥–Ω–æ–π –∑–∞–ø–∏—Å–∏."""
        async with self.get_connection() as conn:
            row = await conn.fetchrow(query, *args)
            return dict(row) if row else None
    
    async def fetch_all(self, query: str, *args) -> List[Dict[str, Any]]:
        """–í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ SELECT –∑–∞–ø—Ä–æ—Å–∞ —Å –≤–æ–∑–≤—Ä–∞—Ç–æ–º –≤—Å–µ—Ö –∑–∞–ø–∏—Å–µ–π."""
        async with self.get_connection() as conn:
            rows = await conn.fetch(query, *args)
            return [dict(row) for row in rows]
    
    async def execute_many(self, query: str, args_list: List[tuple]) -> None:
        """–í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤."""
        async with self.get_connection() as conn:
            await conn.executemany(query, args_list)
    
    async def execute_transaction(self, queries_and_args: List[tuple]):
        """–í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –∑–∞–ø—Ä–æ—Å–æ–≤ –≤ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏."""
        async with self.get_connection() as conn:
            async with conn.transaction():
                for query, args in queries_and_args:
                    await conn.execute(query, *args)
    
    async def run_migrations(self, migrations_dir: str = "database/migrations"):
        """–ó–∞–ø—É—Å–∫ –º–∏–≥—Ä–∞—Ü–∏–π –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö."""
        import os
        import glob
        
        if not os.path.exists(migrations_dir):
            logger.warning(f"Migrations directory {migrations_dir} not found")
            return
        
        migration_files = sorted(glob.glob(os.path.join(migrations_dir, "*.sql")))
        
        async with self.get_connection() as conn:
            # –°–æ–∑–¥–∞–µ–º —Ç–∞–±–ª–∏—Ü—É –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –º–∏–≥—Ä–∞—Ü–∏–π
            await conn.execute("""
                CREATE TABLE IF NOT EXISTS schema_migrations (
                    filename VARCHAR(255) PRIMARY KEY,
                    applied_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
                )
            """)
            
            # –ü–æ–ª—É—á–∞–µ–º —É–∂–µ –ø—Ä–∏–º–µ–Ω–µ–Ω–Ω—ã–µ –º–∏–≥—Ä–∞—Ü–∏–∏
            applied = await conn.fetch("SELECT filename FROM schema_migrations")
            applied_files = {row['filename'] for row in applied}
            
            # –ü—Ä–∏–º–µ–Ω—è–µ–º –Ω–æ–≤—ã–µ –º–∏–≥—Ä–∞—Ü–∏–∏
            for migration_file in migration_files:
                filename = os.path.basename(migration_file)
                
                if filename not in applied_files:
                    logger.info(f"Applying migration: {filename}")
                    
                    with open(migration_file, 'r', encoding='utf-8') as f:
                        migration_sql = f.read()
                    
                    async with conn.transaction():
                        await conn.execute(migration_sql)
                        await conn.execute(
                            "INSERT INTO schema_migrations (filename) VALUES ($1)",
                            filename
                        )
                    
                    logger.info(f"Migration {filename} applied successfully")
                else:
                    logger.debug(f"Migration {filename} already applied")
```


---

## üîß –®–êG 7: –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≥–ª–∞–≤–Ω–æ–≥–æ —Ñ–∞–π–ª–∞ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è

### üìÅ `main.py` - –ò–ó–ú–ï–ù–ï–ù–ò–ï

```python
import asyncio
import logging
import os
import time
from datetime import datetime
import win32api
import ccxt

# –ò–ó–ú–ï–ù–ï–ù–ò–ï: –ò–º–ø–æ—Ä—Ç—ã –Ω–æ–≤—ã—Ö —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–µ–≤
from infrastructure.repositories.deals_repository_v2 import DealsRepositoryV2
from infrastructure.repositories.orders_repository_v2 import OrdersRepositoryV2
from infrastructure.repositories.tickers_repository_v2 import TickersRepositoryV2
from infrastructure.repositories.indicators_repository_v2 import IndicatorsRepositoryV2
from infrastructure.database.postgresql_connection import PostgreSQLConnection

# –°—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –∏–º–ø–æ—Ä—Ç—ã
from domain.entities.currency_pair import CurrencyPair
from domain.entities.ticker import Ticker
from domain.factories.deal_factory import DealFactory
from domain.factories.order_factory import OrderFactory
from domain.services.market_data.ticker_service import TickerService
from domain.services.deals.deal_service import DealService
from domain.services.orders.order_service import OrderService
from infrastructure.connectors.exchange_connector import CcxtExchangeConnector
from infrastructure.utils.performance_logger import PerformanceLogger

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
log_dir = "logs"
os.makedirs(log_dir, exist_ok=True)
log_filename = f"autotrade_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log"
log_filepath = os.path.join(log_dir, log_filename)

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–≥–µ—Ä–æ–≤
file_handler = logging.FileHandler(log_filepath, encoding='utf-8')
stream_handler = logging.StreamHandler()

formatter = logging.Formatter(
    '%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    datefmt='%H:%M:%S'
)

file_handler.setFormatter(formatter)
stream_handler.setFormatter(formatter)

logger = logging.getLogger()
logger.setLevel(logging.INFO)
logger.addHandler(file_handler)
logger.addHandler(stream_handler)

def time_sync_windows():
    """–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –≤—Ä–µ–º–µ–Ω–∏ Windows —Å —Å–µ—Ä–≤–µ—Ä–æ–º –≤—Ä–µ–º–µ–Ω–∏."""
    try:
        logger.info("üïê –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –≤—Ä–µ–º–µ–Ω–∏ —Å time.windows.com...")
        result = win32api.ShellExecute(0, 'runas', 'w32tm', '/resync /force', None, 0)
        if result > 32:
            logger.info("‚úÖ –í—Ä–µ–º—è —É—Å–ø–µ—à–Ω–æ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞–Ω–æ")
        else:
            logger.warning("‚ö†Ô∏è –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –≤—Ä–µ–º–µ–Ω–∏ –∑–∞–≤–µ—Ä—à–∏–ª–∞—Å—å —Å –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ–º")
    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –≤—Ä–µ–º–µ–Ω–∏: {e}")

async def main():
    """
    –ò–ó–ú–ï–ù–ï–ù–ò–ï: –ì–ª–∞–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è —Å –Ω–æ–≤–æ–π –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–æ–π —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–µ–≤.
    """
    logger.info("üöÄ –ó–∞–ø—É—Å–∫ AutoTrade v3.0 —Å –¥–≤—É—Ö—É—Ä–æ–≤–Ω–µ–≤–æ–π –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–æ–π")
    
    # –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –≤—Ä–µ–º–µ–Ω–∏
    time_sync_windows()
    
    # –ù–û–í–û–ï: –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è PostgreSQL –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è
    db_connection_string = os.getenv(
        'DATABASE_URL', 
        'postgresql://autotrade:password@localhost:5432/autotrade'
    )
    
    db_connection = PostgreSQLConnection(db_connection_string)
    
    try:
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ë–î –∏ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –º–∏–≥—Ä–∞—Ü–∏–π
        await db_connection.initialize()
        await db_connection.run_migrations()
        logger.info("‚úÖ –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞ –∏ –º–∏–≥—Ä–∞—Ü–∏–∏ –ø—Ä–∏–º–µ–Ω–µ–Ω—ã")
        
        # –ò–ó–ú–ï–ù–ï–ù–ò–ï: –°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤—ã—Ö —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–µ–≤
        deals_repo = DealsRepositoryV2(db_connection)
        orders_repo = OrdersRepositoryV2(db_connection)
        tickers_repo = TickersRepositoryV2(dumps_directory="dumps", max_memory_records=10000)
        indicators_repo = IndicatorsRepositoryV2(dumps_directory="dumps", max_memory_records=50000)
        
        logger.info("‚úÖ –í—Å–µ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω—ã")
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–∏—Ä–∂–∏
        exchange = ccxt.binance()
        exchange.set_sandbox_mode(True)
        
        # –ó–∞–≥—Ä—É–∑–∫–∞ —Ä—ã–Ω–∫–æ–≤
        markets = exchange.load_markets()
        logger.info(f"üìà –ó–∞–≥—Ä—É–∂–µ–Ω–æ {len(markets)} —Ç–æ—Ä–≥–æ–≤—ã—Ö –ø–∞—Ä")
        
        # –°–æ–∑–¥–∞–Ω–∏–µ –≤–∞–ª—é—Ç–Ω–æ–π –ø–∞—Ä—ã
        if 'ETH/USDT' not in markets:
            logger.error("‚ùå –¢–æ—Ä–≥–æ–≤–∞—è –ø–∞—Ä–∞ ETH/USDT –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")
            return
        
        market_info = markets['ETH/USDT']
        currency_pair = CurrencyPair.from_ccxt_market(market_info)
        logger.info(f"üí± –ù–∞—Å—Ç—Ä–æ–µ–Ω–∞ —Ç–æ—Ä–≥–æ–≤–∞—è –ø–∞—Ä–∞: {currency_pair.symbol}")
        
        # –ò–ó–ú–ï–ù–ï–ù–ò–ï: –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–µ—Ä–≤–∏—Å–æ–≤ —Å –Ω–æ–≤—ã–º–∏ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è–º–∏
        exchange_connector = CcxtExchangeConnector(exchange)
        
        # –§–∞–±—Ä–∏–∫–∏
        order_factory = OrderFactory()
        deal_factory = DealFactory(order_factory)
        
        # –°–µ—Ä–≤–∏—Å—ã
        ticker_service = TickerService(tickers_repo, indicators_repo)
        order_service = OrderService(orders_repo, order_factory, exchange_connector)
        deal_service = DealService(deals_repo, order_service, deal_factory)
        
        # –°–∏—Å—Ç–µ–º–∞ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
        performance_logger = PerformanceLogger(log_interval_seconds=10)
        
        logger.info("üéØ –í—Å–µ —Å–µ—Ä–≤–∏—Å—ã –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω—ã, –Ω–∞—á–∏–Ω–∞–µ–º —Ç–æ—Ä–≥–æ–≤—ã–π —Ü–∏–∫–ª")
        
        # –ò–ó–ú–ï–ù–ï–ù–ò–ï: –û—Å–Ω–æ–≤–Ω–æ–π —Ç–æ—Ä–≥–æ–≤—ã–π —Ü–∏–∫–ª —Å –Ω–æ–≤–æ–π –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–æ–π
        while True:
            cycle_start_time = time.time()
            
            try:
                # –ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–∏–∫–µ—Ä–∞ —Å –±–∏—Ä–∂–∏
                ticker_data = exchange.fetch_ticker('ETH/USDT')
                
                # –°–æ–∑–¥–∞–Ω–∏–µ –æ–±—ä–µ–∫—Ç–∞ —Ç–∏–∫–µ—Ä–∞
                ticker = Ticker(
                    symbol=ticker_data['symbol'],
                    timestamp=ticker_data['timestamp'],
                    datetime=ticker_data['datetime'],
                    high=ticker_data['high'],
                    low=ticker_data['low'],
                    bid=ticker_data['bid'],
                    ask=ticker_data['ask'],
                    last=ticker_data['last'],
                    close=ticker_data['close'],
                    base_volume=ticker_data['baseVolume'],
                    quote_volume=ticker_data['quoteVolume']
                )
                
                # –ò–ó–ú–ï–ù–ï–ù–ò–ï: –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ç–∏–∫–µ—Ä–∞ —á–µ—Ä–µ–∑ –Ω–æ–≤—ã–π —Å–µ—Ä–≤–∏—Å
                await ticker_service.process_ticker(ticker)
                
                # –ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–æ—Ä–≥–æ–≤–æ–≥–æ —Å–∏–≥–Ω–∞–ª–∞
                signal = await ticker_service.get_signal()
                
                # –ù–û–í–û–ï: –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∞—è –∞–Ω–∞–ª–∏—Ç–∏–∫–∞ —á–µ—Ä–µ–∑ DataFrame
                if performance_logger.tick_count % 100 == 0:
                    analytics = await ticker_service.get_analytics_dataframe()
                    logger.info(f"üìä –ê–Ω–∞–ª–∏—Ç–∏–∫–∞: {analytics}")
                    
                    orders_analytics = await order_service.get_orders_analytics()
                    logger.info(f"üìã –û—Ä–¥–µ—Ä–∞: {orders_analytics}")
                
                # –õ–æ–≥–∏–∫–∞ —Ç–æ—Ä–≥–æ–≤–ª–∏ (—É–ø—Ä–æ—â–µ–Ω–Ω–∞—è –¥–ª—è –ø—Ä–∏–º–µ—Ä–∞)
                if signal == "BUY":
                    open_deals = await deal_service.get_open_deals()
                    
                    if len(open_deals) < 3:  # –ú–∞–∫—Å–∏–º—É–º 3 –æ—Ç–∫—Ä—ã—Ç—ã–µ —Å–¥–µ–ª–∫–∏
                        logger.info("üî• –°–∏–≥–Ω–∞–ª –Ω–∞ –ø–æ–∫—É–ø–∫—É! –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é —Å–¥–µ–ª–∫—É...")
                        
                        # –°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–π —Å–¥–µ–ª–∫–∏
                        new_deal = await deal_service.create_new_deal(currency_pair)
                        
                        # –†–∞–∑–º–µ—â–µ–Ω–∏–µ –æ—Ä–¥–µ—Ä–∞ –Ω–∞ –ø–æ–∫—É–ø–∫—É
                        buy_result = await deal_service.place_buy_order(
                            new_deal, 
                            amount=0.01,  # 0.01 ETH
                            budget=30.0   # $30 USDT
                        )
                        
                        if buy_result.success:
                            logger.info(f"‚úÖ –û—Ä–¥–µ—Ä –Ω–∞ –ø–æ–∫—É–ø–∫—É —Ä–∞–∑–º–µ—â–µ–Ω: {buy_result.order.order_id}")
                        else:
                            logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –æ—Ä–¥–µ—Ä–∞: {buy_result.error_message}")
                
                # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–æ–≤ –æ—Ç–∫—Ä—ã—Ç—ã—Ö –æ—Ä–¥–µ—Ä–æ–≤
                open_orders = await order_service.get_open_orders()
                for order in open_orders:
                    await order_service.get_order_status(order)
                
                # –†–∞—Å—á–µ—Ç –≤—Ä–µ–º–µ–Ω–∏ –æ–±—Ä–∞–±–æ—Ç–∫–∏
                processing_time = time.time() - cycle_start_time
                
                # –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
                signals_count = len(ticker.signals) if ticker.signals else 0
                performance_logger.log_tick(ticker.last, processing_time, signals_count)
                
                # –ü–∞—É–∑–∞ –º–µ–∂–¥—É —Ü–∏–∫–ª–∞–º–∏ (1 —Å–µ–∫—É–Ω–¥–∞)
                await asyncio.sleep(1.0)
                
            except KeyboardInterrupt:
                logger.info("üõë –ü–æ–ª—É—á–µ–Ω —Å–∏–≥–Ω–∞–ª –æ—Å—Ç–∞–Ω–æ–≤–∫–∏")
                break
            except Exception as e:
                logger.error(f"‚ùå –û—à–∏–±–∫–∞ –≤ —Ç–æ—Ä–≥–æ–≤–æ–º —Ü–∏–∫–ª–µ: {e}")
                await asyncio.sleep(5.0)  # –ü–∞—É–∑–∞ –ø—Ä–∏ –æ—à–∏–±–∫–µ
    
    except Exception as e:
        logger.error(f"‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏: {e}")
    
    finally:
        # –ù–û–í–û–ï: –ö–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –∑–∞–∫—Ä—ã—Ç–∏–µ —Ä–µ—Å—É—Ä—Å–æ–≤
        logger.info("üîÑ –ó–∞–∫—Ä—ã—Ç–∏–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–π –∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö...")
        
        # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –Ω–∞–∫–æ–ø–ª–µ–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –≤ Parquet
        try:
            today_str = datetime.now().strftime('%Y%m%d')
            
            tickers_dump = f"dumps/final_tickers_{today_str}.parquet"
            await tickers_repo.dump_to_parquet(tickers_dump)
            logger.info(f"üíæ –¢–∏–∫–µ—Ä—ã —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –≤ {tickers_dump}")
            
            indicators_dump = f"dumps/final_indicators_{today_str}.parquet"
            await indicators_repo.dump_to_parquet(indicators_dump)
            logger.info(f"üíæ –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –≤ {indicators_dump}")
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –¥–∞–º–ø–æ–≤: {e}")
        
        # –ó–∞–∫—Ä—ã—Ç–∏–µ –ë–î —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
        await db_connection.close()
        
        logger.info("‚úÖ AutoTrade v3.0 –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ –∑–∞–≤–µ—Ä—à–µ–Ω")

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\nüõë –ü—Ä–æ–≥—Ä–∞–º–º–∞ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º")
    except Exception as e:
        print(f"\n‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: {e}")
```


---

## üéØ –®–ê–ì 8: –°–æ–∑–¥–∞–Ω–∏–µ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤

### üìÅ `requirements.txt` - –î–û–ë–ê–í–õ–ï–ù–ò–Ø

```plain text
# –°—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Å—Ç–∞—é—Ç—Å—è
click
coverage
ipython
jinja2
jupyter
numpy
pandas
pip
pytest
pytz
pyyaml
requests
six
tornado
wheel

# –ù–û–í–´–ï –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –¥–ª—è v3.0
asyncpg>=0.28.0          # PostgreSQL async –¥—Ä–∞–π–≤–µ—Ä
pyarrow>=12.0.0          # –ü–æ–¥–¥–µ—Ä–∂–∫–∞ Parquet —Ñ–∞–π–ª–æ–≤
fastparquet>=0.8.3       # –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π Parquet –¥–≤–∏–∂–æ–∫
sqlalchemy>=2.0.0        # ORM (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
alembic>=1.11.0          # –ú–∏–≥—Ä–∞—Ü–∏–∏ –ë–î (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
python-dotenv>=1.0.0     # –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–º–∏ –æ–∫—Ä—É–∂–µ–Ω–∏—è
```


### üìÅ `.env.example` - –û–ë–ù–û–í–õ–ï–ù–ò–ï

```shell script
# –°—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
BINANCE_API_KEY=your_binance_api_key_here
BINANCE_SECRET_KEY=your_binance_secret_key_here
EXCHANGE_MODE=sandbox

# –ù–û–í–´–ï –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è v3.0
DATABASE_URL=postgresql://autotrade:password@localhost:5432/autotrade
DATABASE_MIN_POOL_SIZE=5
DATABASE_MAX_POOL_SIZE=20

# –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–µ–≤
DUMPS_DIRECTORY=dumps
MAX_MEMORY_TICKERS=10000
MAX_MEMORY_INDICATORS=50000

# –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∞–≤—Ç–æ–¥–∞–º–ø–æ–≤
AUTO_DUMP_INTERVAL=3600          # —Å–µ–∫—É–Ω–¥ (1 —á–∞—Å)
PARQUET_COMPRESSION=snappy       # snappy, gzip, lz4

# –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
LOG_LEVEL=INFO
LOG_DIRECTORY=logs
LOG_MAX_SIZE=100MB
LOG_BACKUP_COUNT=5
```


### üìÅ `docker-compose.yml` - –û–ë–ù–û–í–õ–ï–ù–ò–ï

```yaml
version: '3.8'

services:
  # –ù–û–í–û–ï: PostgreSQL —Å–µ—Ä–≤–∏—Å
  postgres:
    image: postgres:15-alpine
    container_name: autotrade_postgres
    environment:
      POSTGRES_DB: autotrade
      POSTGRES_USER: autotrade
      POSTGRES_PASSWORD: password
      POSTGRES_INITDB_ARGS: "--encoding=UTF-8 --lc-collate=C --lc-ctype=C"
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./database/migrations:/docker-entrypoint-initdb.d
    networks:
      - autotrade_network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U autotrade -d autotrade"]
      interval: 30s
      timeout: 10s
      retries: 5

  # –û–ë–ù–û–í–õ–ï–ù–ù–´–ô: AutoTrade –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ
  autotrade:
    build: .
    container_name: autotrade_app
    environment:
      DATABASE_URL: postgresql://autotrade:password@postgres:5432/autotrade
      DUMPS_DIRECTORY: /app/dumps
      LOG_DIRECTORY: /app/logs
    volumes:
      - ./dumps:/app/dumps
      - ./logs:/app/logs
      - ./.env:/app/.env
    depends_on:
      postgres:
        condition: service_healthy
    networks:
      - autotrade_network
    restart: unless-stopped

  # –ù–û–í–û–ï: pgAdmin –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ë–î
  pgadmin:
    image: dpage/pgadmin4:latest
    container_name: autotrade_pgadmin
    environment:
      PGADMIN_DEFAULT_EMAIL: admin@autotrade.local
      PGADMIN_DEFAULT_PASSWORD: admin
      PGADMIN_CONFIG_SERVER_MODE: 'False'
    ports:
      - "8080:80"
    volumes:
      - pgadmin_data:/var/lib/pgadmin
    depends_on:
      - postgres
    networks:
      - autotrade_network

volumes:
  postgres_data:
  pgadmin_data:

networks:
  autotrade_network:
    driver: bridge
```


---

## üìã –†–µ–∑—é–º–µ –ü–ª–∞–Ω–∞ –ú–∏–≥—Ä–∞—Ü–∏–∏

### üéØ –ò–∑–º–µ–Ω–µ–Ω–∏—è –ø–æ —Ñ–∞–π–ª–∞–º:

#### ‚úÖ –ù–û–í–´–ï –§–ê–ô–õ–´:
1. `src/domain/repositories/base_repository.py` - –ë–∞–∑–æ–≤—ã–µ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ã
2. `src/domain/dto/dataframe_convertible.py` - DTO –¥–ª—è –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏
3. `src/infrastructure/repositories/deals_repository_v2.py` - –ù–æ–≤—ã–π —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π —Å–¥–µ–ª–æ–∫
4. `src/infrastructure/repositories/orders_repository_v2.py` - –ù–æ–≤—ã–π —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π –æ—Ä–¥–µ—Ä–æ–≤
5. `src/infrastructure/repositories/tickers_repository_v2.py` - –ù–æ–≤—ã–π —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π —Ç–∏–∫–µ—Ä–æ–≤
6. `src/infrastructure/repositories/indicators_repository_v2.py` - –ù–æ–≤—ã–π —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤
7. `src/infrastructure/database/postgresql_connection.py` - –ú–µ–Ω–µ–¥–∂–µ—Ä –ë–î
8. `database/migrations/001_create_tables.sql` - SQL —Å—Ö–µ–º–∞

#### üîÑ –ò–ó–ú–ï–ù–ï–ù–ù–´–ï –§–ê–ô–õ–´:
1. `src/domain/entities/deal.py` - –î–æ–±–∞–≤–ª–µ–Ω—ã –º–µ—Ç–æ–¥—ã `to_dict()` –∏ `from_dict()`
2. `src/domain/entities/order.py` - –î–æ–±–∞–≤–ª–µ–Ω—ã –º–µ—Ç–æ–¥—ã `to_dict()` –∏ `from_dict()`
3. `src/domain/entities/ticker.py` - –î–æ–±–∞–≤–ª–µ–Ω—ã –º–µ—Ç–æ–¥—ã `to_dict()` –∏ `from_dict()`
4. `src/domain/entities/indicator_data.py` - –û–±–Ω–æ–≤–ª–µ–Ω—ã –º–µ—Ç–æ–¥—ã –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏
5. `src/domain/services/market_data/ticker_service.py` - –ü–µ—Ä–µ—Ö–æ–¥ –Ω–∞ –Ω–æ–≤—ã–µ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–∏
6. `src/domain/services/orders/order_service.py` - –ü–µ—Ä–µ—Ö–æ–¥ –Ω–∞ async –º–µ—Ç–æ–¥—ã
7. `main.py` - –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –Ω–æ–≤–æ–π –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã
8. `requirements.txt` - –î–æ–±–∞–≤–ª–µ–Ω—ã –Ω–æ–≤—ã–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏
9. `.env.example` - –ù–æ–≤—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è
10. `docker-compose.yml` - –î–æ–±–∞–≤–ª–µ–Ω PostgreSQL

### üöÄ –ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞ –Ω–æ–≤–æ–π –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã:

1. **‚ö° –°–∫–æ—Ä–æ—Å—Ç—å**: –í—Å–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –≤ –ø–∞–º—è—Ç–∏ —á–µ—Ä–µ–∑ Pandas DataFrame
2. **üîí –ù–∞–¥–µ–∂–Ω–æ—Å—Ç—å**: –ê—Ç–æ–º–∞—Ä–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ —Å—Ä–∞–∑—É –≤ PostgreSQL
3. **üìä –ê–Ω–∞–ª–∏—Ç–∏–∫–∞**: –ü—Ä—è–º–æ–π –¥–æ—Å—Ç—É–ø –∫ DataFrame –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞
4. **üóÑÔ∏è –ú–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º–æ—Å—Ç—å**: –ü–æ—Ç–æ–∫–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ –≤ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω—ã—Ö Parquet –¥–∞–º–ø–∞—Ö
5. **üß™ –¢–µ—Å—Ç–∏—Ä—É–µ–º–æ—Å—Ç—å**: –ß–µ—Ç–∫–æ–µ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ —Å–ª–æ–µ–≤ –∏ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–æ–≤
6. **üîÑ –í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏–º–æ—Å—Ç—å**: –ü–æ–ª–Ω–æ–µ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è –ø–æ—Å–ª–µ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞

–≠—Ç–æ—Ç –ø–ª–∞–Ω –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç –ø–ª–∞–≤–Ω—É—é –º–∏–≥—Ä–∞—Ü–∏—é —Å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ–º –≤—Å–µ—Ö —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö —Ñ—É–Ω–∫—Ü–∏–π –∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ–º –Ω–æ–≤—ã—Ö –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ –∏ –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏—è.