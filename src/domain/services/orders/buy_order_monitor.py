# domain/services/buy_order_monitor.py.new
import asyncio
import logging
import time
from datetime import datetime
from typing import List, Optional, Tuple
from domain.entities.order import Order
from domain.services.orders.order_service import OrderService
from domain.services.deals.deal_service import DealService
from infrastructure.connectors.exchange_connector import CcxtExchangeConnector

logger = logging.getLogger(__name__)

class BuyOrderMonitor:
    """
    üïí –ü—Ä–æ—Å—Ç–æ–π –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –ø—Ä–æ—Ç—É—Ö—à–∏—Ö BUY –æ—Ä–¥–µ—Ä–æ–≤
    
    –ü—Ä–æ–≤–µ—Ä—è–µ—Ç —Ç–æ–ª—å–∫–æ BUY –æ—Ä–¥–µ—Ä–∞ –Ω–∞:
    - –í—Ä–µ–º—è –∂–∏–∑–Ω–∏ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 15 –º–∏–Ω—É—Ç)
    - –û—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ —Ü–µ–Ω—ã –æ—Ç —Ä—ã–Ω–∫–∞ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 3%)
    
    –ü—Ä–∏ –ø—Ä–µ–≤—ã—à–µ–Ω–∏–∏ –ª–∏–º–∏—Ç–æ–≤ - –æ—Ç–º–µ–Ω—è–µ—Ç –∏ –ø–µ—Ä–µ—Å–æ–∑–¥–∞–µ—Ç –æ—Ä–¥–µ—Ä –ø–æ –Ω–æ–≤–æ–π —Ü–µ–Ω–µ
    """

    def __init__(
        self,
        order_service: OrderService,
        deal_service: DealService, # ‚ùóÔ∏è –î–û–ë–ê–í–õ–ï–ù–û
        exchange_connector: CcxtExchangeConnector,
        max_age_minutes: float = 15.0,
        max_price_deviation_percent: float = 3.0,
        check_interval_seconds: int = 60,
        grace_period_seconds: int = 60,  # –ü–µ—Ä–∏–æ–¥ –æ–∂–∏–¥–∞–Ω–∏—è –ø–µ—Ä–µ–¥ –ø—Ä–æ–≤–µ—Ä–∫–æ–π –Ω–æ–≤—ã—Ö –æ—Ä–¥–µ—Ä–æ–≤
        min_time_between_recreations_minutes: float = 0.0
    ):
        self.order_service = order_service
        self.deal_service = deal_service # ‚ùóÔ∏è –î–û–ë–ê–í–õ–ï–ù–û
        self.exchange_connector = exchange_connector
        self.max_age_minutes = max_age_minutes
        self.max_price_deviation_percent = max_price_deviation_percent
        self.check_interval_seconds = check_interval_seconds
        self.grace_period_seconds = grace_period_seconds
        self.min_time_between_recreations_minutes = min_time_between_recreations_minutes
        
        self.running = False
        self.stats = {
            'checks_performed': 0,
            'stale_orders_found': 0,
            'orders_cancelled': 0,
            'orders_recreated': 0
        }
        
        # –£–ª—É—á—à–µ–Ω–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
        self.quiet_checks_count = 0  # –°—á–µ—Ç—á–∏–∫ "—Ç–∏—Ö–∏—Ö" –ø—Ä–æ–≤–µ—Ä–æ–∫
        self.last_summary_time = 0   # –í—Ä–µ–º—è –ø–æ—Å–ª–µ–¥–Ω–µ–π —Å–≤–æ–¥–∫–∏
        self.summary_interval_minutes = 5  # –ò–Ω—Ç–µ—Ä–≤–∞–ª —Å–≤–æ–¥–∫–∏ –≤ –º–∏–Ω—É—Ç–∞—Ö
        
        # –ê–Ω—Ç–∏-–¥–µ—Ä–≥–∞–Ω—å–µ: –ø–æ—Å–ª–µ–¥–Ω—è—è –ø–µ—Ä–µ—Å–æ–∑–¥–∞–Ω–Ω–∞—è –º–µ—Ç–∫–∞ –≤—Ä–µ–º–µ–Ω–∏ –ø–æ deal_id
        self._last_recreation_by_deal = {}  # deal_id -> epoch seconds

    async def start_monitoring(self):
        """–ó–∞–ø—É—Å–∫ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –≤ —Ñ–æ–Ω–µ"""
        if self.running:
            logger.warning("‚ö†Ô∏è BuyOrderMonitor already running")
            return
            
        self.running = True
        logger.info(f"üïí –ó–∞–ø—É—Å–∫ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ BUY –æ—Ä–¥–µ—Ä–æ–≤ (–ø—Ä–æ–≤–µ—Ä–∫–∞ –∫–∞–∂–¥—ã–µ {self.check_interval_seconds}—Å)")
        
        while self.running:
            try:
                await self.check_stale_buy_orders()
                await asyncio.sleep(self.check_interval_seconds)
            except Exception as e:
                logger.error(f"‚ùå –û—à–∏–±–∫–∞ –≤ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–µ BUY –æ—Ä–¥–µ—Ä–æ–≤: {e}")
                await asyncio.sleep(30)  # –ü–∞—É–∑–∞ –ø—ÄÔøΩÔøΩ –æ—à–∏–±–∫–µ

    def stop_monitoring(self):
        """–û—Å—Ç–∞–Ω–æ–≤–∫–∞ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞"""
        self.running = False
        logger.info("üî¥ –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ BUY –æ—Ä–¥–µ—Ä–æ–≤ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")

    async def check_stale_buy_orders(self):
        """–ê–∫—Ç–∏–≤–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –≤—Å–µ—Ö –æ—Ç–∫—Ä—ã—Ç—ã—Ö BUY –æ—Ä–¥–µ—Ä–æ–≤ —Å —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–µ–π –±–∏—Ä–∂–∏"""
        try:
            self.stats['checks_performed'] += 1
            
            # –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ –æ—Ç–∫—Ä—ã—Ç—ã–µ –æ—Ä–¥–µ—Ä–∞
            open_orders = self.order_service.get_open_orders()
            
            # –§–∏–ª—å—Ç—Ä—É–µ–º —Ç–æ–ª—å–∫–æ BUY –æ—Ä–¥–µ—Ä–∞
            buy_orders = [order for order in open_orders if order.side == Order.SIDE_BUY]
            
            # –£–º–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ: –¥–µ—Ç–∞–ª—å–Ω–æ —Ç–æ–ª—å–∫–æ –ø—Ä–∏ –Ω–∞–ª–∏—á–∏–∏ –æ—Ä–¥–µ—Ä–æ–≤
            if buy_orders:
                logger.info(f"üîç –ú–û–ù–ò–¢–û–†–ò–ù–ì BUY: –ø—Ä–æ–≤–µ—Ä—è–µ–º {len(buy_orders)} –æ—Ä–¥–µ—Ä–æ–≤")
                self.quiet_checks_count = 0  # –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—á–µ—Ç—á–∏–∫ —Ç–∏—Ö–∏—Ö –ø—Ä–æ–≤–µ—Ä–æ–∫
            else:
                self.quiet_checks_count += 1
                logger.debug("‚ÑπÔ∏è –ù–µ—Ç –æ—Ç–∫—Ä—ã—Ç—ã—Ö BUY –æ—Ä–¥–µ—Ä–æ–≤ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏")
                
                # –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∞—è —Å–≤–æ–¥–∫–∞ –≤–º–µ—Å—Ç–æ –ø–æ—Å—Ç–æ—è–Ω–Ω–æ–≥–æ —à—É–º–∞
                await self._log_periodic_summary()
                return
            
            for order in buy_orders:
                # üÜï –°–ò–ù–•–†–û–ù–ò–ó–ê–¶–ò–Ø: –û–±–Ω–æ–≤–ª—è–µ–º –æ—Ä–¥–µ—Ä —Å –∞–∫—Ç—É–∞–ª—å–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏ –±–∏—Ä–∂–∏
                try:
                    # –ü–æ–ª—É—á–∞–µ–º —Å–≤–µ–∂–∏–µ –¥–∞–Ω–Ω—ã–µ —Å –±–∏—Ä–∂–∏
                    if order.exchange_id:
                        exchange_data = await self.exchange_connector.fetch_order(order.exchange_id, order.symbol)
                        if exchange_data:
                            # –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ–º –Ω–∞—à –æ—Ä–¥–µ—Ä —Å –¥–∞–Ω–Ω—ã–º–∏ –±–∏—Ä–∂–∏
                            was_updated = order.sync_with_exchange_data(exchange_data)
                            if was_updated:
                                # –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π –æ—Ä–¥–µ—Ä
                                self.order_service.orders_repo.update_order(order)
                                logger.debug(f"üîÑ –û—Ä–¥–µ—Ä {order.order_id} —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞–Ω —Å –±–∏—Ä–∂–µ–π")
                    
                    updated_order = order  # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –æ—Ä–¥–µ—Ä
                    
                except Exception as e:
                    logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –æ—Ä–¥–µ—Ä–∞ {order.order_id}: {e}")
                    # Fallback: –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å—Ç–∞—Ä—ã–π –º–µ—Ç–æ–¥
                    try:
                        updated_order = await self.order_service.get_order_status(order)
                        if not updated_order:
                            logger.warning(f"‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç—É—Å –æ—Ä–¥–µ—Ä–∞ {order.order_id}")
                            continue
                    except Exception as e2:
                        logger.error(f"‚ùå Fallback –æ—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–∞ –æ—Ä–¥–µ—Ä–∞ {order.order_id}: {e2}")
                        continue
                
                # –î–µ—Ç–∞–ª—å–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è –æ—Ä–¥–µ—Ä–∞
                age_minutes = self._get_order_age_minutes(updated_order)
                fill_percentage = updated_order.get_fill_percentage() if hasattr(updated_order, 'get_fill_percentage') else 0.0
                
                logger.info(f"üìä BUY {updated_order.order_id}: —Å—Ç–∞—Ç—É—Å={updated_order.status}, "
                           f"–∑–∞–ø–æ–ª–Ω–µ–Ω–æ={fill_percentage:.1%}, –≤–æ–∑—Ä–∞—Å—Ç={age_minutes:.1f}–º–∏–Ω")
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ "–ø—Ä–æ—Ç—É—Ö–∞–Ω–∏–µ"
                is_stale, reason = await self._is_order_stale(updated_order)
                if is_stale:
                    logger.warning(f"üö® –ü–†–û–¢–£–•–®–ò–ô BUY –û–ë–ù–ê–†–£–ñ–ï–ù: {reason}")
                    await self._handle_stale_buy_order(updated_order)
                    
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ BUY –æ—Ä–¥–µ—Ä–æ–≤: {e}")

    async def _log_periodic_summary(self):
        """–ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–≤–æ–¥–∫–∏ –≤–º–µ—Å—Ç–æ –ø–æ—Å—Ç–æ—è–Ω–Ω–æ–≥–æ —à—É–º–∞"""
        current_time = time.time()
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω—É–∂–Ω–æ –ª–∏ –≤—ã–≤–æ–¥–∏—Ç—å —Å–≤–æ–¥–∫—É
        if (current_time - self.last_summary_time) >= (self.summary_interval_minutes * 60):
            self.last_summary_time = current_time
            
            # –í—ã–≤–æ–¥–∏–º –∏–Ω—Ñ–æ—Ä–º–∞—Ç–∏–≤–Ω—É—é —Å–≤–æ–¥–∫—É
            logger.info(f"üìä BUY –ú–û–ù–ò–¢–û–† –°–í–û–î–ö–ê: "
                       f"—Ç–∏—Ö–∏—Ö –ø—Ä–æ–≤–µ—Ä–æ–∫ –∑–∞ {self.summary_interval_minutes}–º–∏–Ω: {self.quiet_checks_count}, "
                       f"–≤—Å–µ–≥–æ –ø—Ä–æ–≤–µ—Ä–æ–∫: {self.stats['checks_performed']}, "
                       f"–Ω–∞–π–¥–µ–Ω–æ —Ç—É—Ö–ª—è–∫–æ–≤: {self.stats['stale_orders_found']}, "
                       f"–ø–µ—Ä–µ—Å–æ–∑–¥–∞–Ω–æ: {self.stats['orders_recreated']}")
            
            # –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—á–µ—Ç—á–∏–∫ —Ç–∏—Ö–∏—Ö –ø—Ä–æ–≤–µ—Ä–æ–∫
            self.quiet_checks_count = 0

    def _get_order_age_seconds(self, order: Order) -> float:
        """–í—ã—á–∏—Å–ª—è–µ—Ç –≤–æ–∑—Ä–∞—Å—Ç –æ—Ä–¥–µ—Ä–∞ –≤ —Å–µ–∫—É–Ω–¥–∞—Ö, –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç int(ms), datetime, str(ISO)."""
        try:
            current_time = int(time.time() * 1000)
            created_at_ms = None

            ca = getattr(order, 'created_at', None)
            if hasattr(ca, 'timestamp'):
                created_at_ms = int(ca.timestamp() * 1000)
            elif isinstance(ca, (int, float)):
                created_at_ms = int(ca)
            elif isinstance(ca, str) and ca:
                try:
                    created_at_ms = int(datetime.fromisoformat(ca).timestamp() * 1000)
                except Exception:
                    created_at_ms = None

            if created_at_ms is None:
                logger.warning(f"‚ö†Ô∏è –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø created_at –¥–ª—è –æ—Ä–¥–µ—Ä–∞ {order.order_id}: {type(ca)} -> —Å—á–∏—Ç–∞–µ–º 0—Å")
                return 0.0

            age_seconds = (current_time - created_at_ms) / 1000.0
            return max(0.0, age_seconds)
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –≤—ã—á–∏—Å–ª–µ–Ω–∏—è –≤–æ–∑—Ä–∞—Å—Ç–∞ –æ—Ä–¥–µ—Ä–∞ {order.order_id}: {e}")
            return 0.0

    def _get_order_age_minutes(self, order: Order) -> float:
        """–í—ã—á–∏—Å–ª—è–µ—Ç –≤–æ–∑—Ä–∞—Å—Ç –æ—Ä–¥–µ—Ä–∞ –≤ –º–∏–Ω—É—Ç–∞—Ö, –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç int(ms), datetime, str(ISO)."""
        try:
            current_time = int(time.time() * 1000)
            created_at_ms = None

            ca = getattr(order, 'created_at', None)
            if hasattr(ca, 'timestamp'):
                created_at_ms = int(ca.timestamp() * 1000)
            elif isinstance(ca, (int, float)):
                created_at_ms = int(ca)
            elif isinstance(ca, str) and ca:
                try:
                    created_at_ms = int(datetime.fromisoformat(ca).timestamp() * 1000)
                except Exception:
                    created_at_ms = None

            if created_at_ms is None:
                logger.warning(f"‚ö†Ô∏è –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø created_at –¥–ª—è –æ—Ä–¥–µ—Ä–∞ {order.order_id}: {type(ca)} -> —Å—á–∏—Ç–∞–µ–º 0–º–∏–Ω")
                return 0.0

            age_minutes = (current_time - created_at_ms) / 1000.0 / 60.0
            return max(0.0, age_minutes)
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –≤—ã—á–∏—Å–ª–µ–Ω–∏—è –≤–æ–∑—Ä–∞—Å—Ç–∞ –æ—Ä–¥–µ—Ä–∞ {order.order_id}: {e}")
            return 0.0

    async def _is_order_stale(self, order: Order) -> Tuple[bool, str]:
        """–ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–æ—Ç—É—Ö–∞–Ω–∏—è BUY –æ—Ä–¥–µ—Ä–∞ —Å —É–ª—É—á—à–µ–Ω–Ω–æ–π –ª–æ–≥–∏–∫–æ–π"""
        try:
            # 1. –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–æ–∑—Ä–∞—Å—Ç–∞ –æ—Ä–¥–µ—Ä–∞
            age_minutes = self._get_order_age_minutes(order)
            
            # –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ë–æ–ª–µ–µ –∞–≥—Ä–µ—Å—Å–∏–≤–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ –≤—Ä–µ–º–µ–Ω–∏
            if age_minutes > self.max_age_minutes:
                reason = f"–æ—Ä–¥–µ—Ä {order.order_id} –ø—Ä–æ—Ç—É—Ö –ø–æ –≤—Ä–µ–º–µ–Ω–∏: {age_minutes:.1f} –º–∏–Ω > {self.max_age_minutes} –º–∏–Ω"
                return True, reason
            
            # –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –¥–ª—è –æ—Ä–¥–µ—Ä–æ–≤ —Å –Ω—É–ª–µ–≤—ã–º –∑–∞–ø–æ–ª–Ω–µ–Ω–∏–µ–º
            fill_percentage = order.get_fill_percentage()
            if age_minutes > (self.max_age_minutes * 0.5) and fill_percentage == 0.0:
                reason = f"–æ—Ä–¥–µ—Ä {order.order_id} –ø—Ä–æ—Ç—É—Ö: {age_minutes:.1f} –º–∏–Ω –±–µ–∑ –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è (>{self.max_age_minutes * 0.5:.1f} –º–∏–Ω)"
                return True, reason
            
            # 2. –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏—è —Ü–µ–Ω—ã –æ—Ç —Ä—ã–Ω–∫–∞ (—Å–∏–º–º–µ—Ç—Ä–∏—á–Ω–æ, –∏—Å–ø–æ–ª—å–∑—É–µ–º best bid –∏–∑ —Å—Ç–∞–∫–∞–Ω–∞)
            try:
                market_price = None
                try:
                    order_book = await self.exchange_connector.fetch_order_book(order.symbol)
                    if order_book and getattr(order_book, 'bids', None) and len(order_book.bids) > 0:
                        market_price = float(order_book.bids[0][0])
                except Exception:
                    market_price = None
                if market_price is None:
                    ticker = await self.exchange_connector.fetch_ticker(order.symbol)
                    market_price = float(getattr(ticker, 'last', 0.0))

                if order.price and market_price:
                    price_deviation_abs = abs((market_price - float(order.price)) / float(order.price)) * 100.0
                    if price_deviation_abs > self.max_price_deviation_percent and order.get_fill_percentage() == 0.0:
                        direction = '–Ω–∏–∂–µ' if market_price < order.price else '–≤—ã—à–µ'
                        reason = (f"–æ—Ä–¥–µ—Ä {order.order_id} –ø—Ä–æ—Ç—É—Ö –ø–æ —Ü–µ–Ω–µ: —Ä—ã–Ω–æ–∫ {market_price}, –æ—Ä–¥–µ—Ä {order.price}, "
                                  f"–æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ {price_deviation_abs:.2f}% ({direction})")
                        return True, reason
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —Ü–µ–Ω—É/—Å—Ç–∞–∫–∞–Ω –¥–ª—è {order.symbol}: {e}")
                # –ï—Å–ª–∏ –Ω–µ –º–æ–∂–µ–º –ø–æ–ª—É—á–∏—Ç—å —Ü–µ–Ω—É, –ø—Ä–æ–≤–µ—Ä—è–µ–º —Ç–æ–ª—å–∫–æ –ø–æ –≤—Ä–µ–º–µ–Ω–∏

            return False, ""
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –æ—Ä–¥–µ—Ä–∞ {order.order_id}: {e}")
            return False, ""

    async def _handle_stale_buy_order(self, order: Order):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –ø—Ä–æ—Ç—É—Ö—à–µ–≥–æ BUY: throttle + –æ—Ç–º–µ–Ω–∞ + –ø–µ—Ä–µ—Å–æ–∑–¥–∞–Ω–∏–µ + –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ PENDING SELL"""
        try:
            self.stats['stale_orders_found'] += 1

            # –ê–Ω—Ç–∏-–¥–µ—Ä–≥–∞–Ω—å–µ –ø–æ deal_id
            now = time.time()
            last = self._last_recreation_by_deal.get(order.deal_id)
            min_gap = (self.min_time_between_recreations_minutes or 0.0) * 60.0
            if last is not None and (now - last) < min_gap:
                wait_left = min_gap - (now - last)
                logger.info(f"‚è≥ –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –ø–µ—Ä–µ—Å–æ–∑–¥–∞–Ω–∏–µ BUY –¥–ª—è —Å–¥–µ–ª–∫–∏ {order.deal_id}: –ø–æ–¥–æ–∂–¥–∏—Ç–µ –µ—â—ë {wait_left:.1f}—Å")
                return

            logger.warning(f"üö® –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ø—Ä–æ—Ç—É—Ö—à–∏–π BUY –æ—Ä–¥–µ—Ä {order.order_id} (deal {order.deal_id})")

            # 1. –û—Ç–º–µ–Ω—è–µ–º —Å—Ç–∞—Ä—ã–π BUY –æ—Ä–¥–µ—Ä
            cancel_success = await self.order_service.cancel_order(order)
            if not cancel_success:
                logger.error(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–º–µ–Ω–∏—Ç—å BUY –æ—Ä–¥–µ—Ä {order.order_id}")
                return
            self.stats['orders_cancelled'] += 1
            logger.info(f"‚úÖ BUY –æ—Ä–¥–µ—Ä {order.order_id} –æ—Ç–º–µ–Ω–µ–Ω")

            # 2. –ü–µ—Ä–µ—Å–æ–∑–¥–∞–µ–º BUY –æ—Ä–¥–µ—Ä –ø–æ –Ω–æ–≤–æ–π —Ü–µ–Ω–µ
            new_buy_order = await self._recreate_buy_order(order)
            if not new_buy_order:
                logger.error(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–µ—Ä–µ—Å–æ–∑–¥–∞—Ç—å BUY –æ—Ä–¥–µ—Ä")
                return

            self.stats['orders_recreated'] += 1
            logger.info(f"‚úÖ BUY –æ—Ä–¥–µ—Ä –ø–µ—Ä–µ—Å–æ–∑–¥–∞–Ω: {order.order_id} -> {new_buy_order.order_id}")

            # 3. –û–±–Ω–æ–≤–ª—è–µ–º —Å–≤—è–∑–∞–Ω–Ω—ã–π PENDING SELL –≤ —Ä–∞–º–∫–∞—Ö —Ç–æ–π –∂–µ —Å–¥–µ–ª–∫–∏
            try:
                deal = self.deal_service.get_deal_by_id(order.deal_id)
                profit_markup = 0.0
                if deal and getattr(deal, 'currency_pair', None):
                    profit_markup = float(getattr(deal.currency_pair, 'profit_markup', 0.0) or 0.0)

                # –ò—â–µ–º PENDING SELL –æ—Ä–¥–µ—Ä –ø–æ —Ç–æ–π –∂–µ —Å–¥–µ–ª–∫–µ
                deal_orders = self.order_service.orders_repo.get_orders_by_deal(order.deal_id)
                pending_sells = [o for o in deal_orders if o.side == Order.SIDE_SELL and o.is_pending()]
                if pending_sells:
                    sell = pending_sells[0]
                    # –ü–µ—Ä–µ—Å—á–∏—Ç—ã–≤–∞–µ–º —Ü–µ–Ω—É SELL
                    raw_new_sell_price = float(new_buy_order.price) * (1.0 + profit_markup)
                    # –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º —Ç–æ—á–Ω–æ—Å—Ç—å —Ü–µ–Ω—ã/–∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ —á–µ—Ä–µ–∑ —Ñ–∞–±—Ä–∏–∫—É
                    try:
                        adj_price = self.order_service.order_factory.adjust_price_precision(new_buy_order.symbol, raw_new_sell_price)
                    except Exception:
                        adj_price = raw_new_sell_price
                    try:
                        adj_amount = self.order_service.order_factory.adjust_amount_precision(new_buy_order.symbol, new_buy_order.amount)
                    except Exception:
                        adj_amount = new_buy_order.amount

                    sell.price = adj_price
                    sell.amount = adj_amount
                    sell.last_update = int(time.time() * 1000)
                    # –û—Å—Ç–∞–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å PENDING, exchange_id = None
                    sell.exchange_id = None
                    self.order_service.orders_repo.update_order(sell)
                    logger.info(f"üîÅ –û–±–Ω–æ–≤–ª—ë–Ω PENDING SELL {sell.order_id} –≤ —Å–¥–µ–ª–∫–µ {order.deal_id}: –Ω–æ–≤–∞—è —Ü–µ–Ω–∞ {adj_price}, –æ–±—ä—ë–º {adj_amount}")
                else:
                    logger.debug(f"‚ÑπÔ∏è –í —Å–¥–µ–ª–∫–µ {order.deal_id} –Ω–µ—Ç PENDING SELL –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è")

                # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–∞–π–º–µ—Ä –∞–Ω—Ç–∏-–¥–µ—Ä–≥–∞–Ω—å—è
                self._last_recreation_by_deal[order.deal_id] = time.time()
            except Exception as e:
                logger.error(f"‚ùå –û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å–≤—è–∑–∞–Ω–Ω–æ–≥–æ SELL –¥–ª—è —Å–¥–µ–ª–∫–∏ {order.deal_id}: {e}")

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø—Ä–æ—Ç—É—Ö—à–µ–≥–æ BUY –æ—Ä–¥–µ—Ä–∞ {order.order_id}: {e}", exc_info=True)

    async def _recreate_buy_order(self, old_order: Order) -> Optional[Order]:
        """–ü—Ä–æ—Å—Ç–æ–µ –ø–µ—Ä–µ—Å–æ–∑–¥–∞–Ω–∏–µ BUY –æ—Ä–¥–µ—Ä–∞ –ø–æ —Ç–µ–∫—É—â–µ–π —Ä—ã–Ω–æ—á–Ω–æ–π —Ü–µ–Ω–µ (–∫–∞–∫ –≤ –≤–µ—Ä—Å–∏–∏ 2.3.4)"""
        try:
            # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â—É—é —Ü–µ–Ω—É
            ticker = await self.exchange_connector.fetch_ticker(old_order.symbol)
            new_price = float(ticker.last) * 0.999  # –ù–µ–±–æ–ª—å—à–∞—è —Å–∫–∏–¥–∫–∞ –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è

            logger.info(f"üîÑ –ü–µ—Ä–µ—Å–æ–∑–¥–∞–µ–º BUY –æ—Ä–¥–µ—Ä: —Å—Ç–∞—Ä–∞—è —Ü–µ–Ω–∞ {old_order.price}, –Ω–æ–≤–∞—è —Ü–µ–Ω–∞ {new_price}")

            # –°–æ–∑–¥–∞–µ–º –∏ —Ä–∞–∑–º–µ—â–∞–µ–º –Ω–æ–≤—ã–π –æ—Ä–¥–µ—Ä
            execution_result = await self.order_service.create_and_place_buy_order(
                symbol=old_order.symbol,
                amount=old_order.amount,
                price=new_price,
                deal_id=old_order.deal_id
            )
            
            return execution_result.order if execution_result.success else None
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–µ—Ä–µ—Å–æ–∑–¥–∞–Ω–∏—è BUY –æ—Ä–¥–µ—Ä–∞: {e}", exc_info=True)
            return None


    def get_statistics(self) -> dict:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ —Ä–∞–±–æ—Ç—ã –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞"""
        return {
            'running': self.running,
            'max_age_minutes': self.max_age_minutes,
            'max_price_deviation_percent': self.max_price_deviation_percent,
            'check_interval_seconds': self.check_interval_seconds,
            **self.stats
        }

    def configure(
        self,
        max_age_minutes: float = None,
        max_price_deviation_percent: float = None,
        check_interval_seconds: int = None
    ):
        """–ò–∑–º–µ–Ω–µ–Ω–∏–µ –Ω–∞—Å—Ç—Ä–æ–µ–∫ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞"""
        if max_age_minutes is not None:
            self.max_age_minutes = max_age_minutes
        if max_price_deviation_percent is not None:
            self.max_price_deviation_percent = max_price_deviation_percent
        if check_interval_seconds is not None:
            self.check_interval_seconds = check_interval_seconds
            
        logger.info(f"‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –æ–±–Ω–æ–≤–ª–µ–Ω—ã: {self.get_statistics()}")
